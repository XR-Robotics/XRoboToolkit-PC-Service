// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PXREAService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_PXREAService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_PXREAService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_PXREAService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_PXREAService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_PXREAService_2eproto;
namespace PXREAService {
class AppPlayInfo;
struct AppPlayInfoDefaultTypeInternal;
extern AppPlayInfoDefaultTypeInternal _AppPlayInfo_default_instance_;
class ControllerBattery;
struct ControllerBatteryDefaultTypeInternal;
extern ControllerBatteryDefaultTypeInternal _ControllerBattery_default_instance_;
class ControllerHomeButtonFunction;
struct ControllerHomeButtonFunctionDefaultTypeInternal;
extern ControllerHomeButtonFunctionDefaultTypeInternal _ControllerHomeButtonFunction_default_instance_;
class ControllerInfo;
struct ControllerInfoDefaultTypeInternal;
extern ControllerInfoDefaultTypeInternal _ControllerInfo_default_instance_;
class CurrentApplication;
struct CurrentApplicationDefaultTypeInternal;
extern CurrentApplicationDefaultTypeInternal _CurrentApplication_default_instance_;
class DeviceAliasInfo;
struct DeviceAliasInfoDefaultTypeInternal;
extern DeviceAliasInfoDefaultTypeInternal _DeviceAliasInfo_default_instance_;
class DeviceBattery;
struct DeviceBatteryDefaultTypeInternal;
extern DeviceBatteryDefaultTypeInternal _DeviceBattery_default_instance_;
class DeviceBlob;
struct DeviceBlobDefaultTypeInternal;
extern DeviceBlobDefaultTypeInternal _DeviceBlob_default_instance_;
class DeviceBytesInfo;
struct DeviceBytesInfoDefaultTypeInternal;
extern DeviceBytesInfoDefaultTypeInternal _DeviceBytesInfo_default_instance_;
class DeviceControlParameterJson;
struct DeviceControlParameterJsonDefaultTypeInternal;
extern DeviceControlParameterJsonDefaultTypeInternal _DeviceControlParameterJson_default_instance_;
class DeviceID;
struct DeviceIDDefaultTypeInternal;
extern DeviceIDDefaultTypeInternal _DeviceID_default_instance_;
class DeviceModel;
struct DeviceModelDefaultTypeInternal;
extern DeviceModelDefaultTypeInternal _DeviceModel_default_instance_;
class DeviceMonitorParameter;
struct DeviceMonitorParameterDefaultTypeInternal;
extern DeviceMonitorParameterDefaultTypeInternal _DeviceMonitorParameter_default_instance_;
class DeviceMonitorSharedMemoryKey;
struct DeviceMonitorSharedMemoryKeyDefaultTypeInternal;
extern DeviceMonitorSharedMemoryKeyDefaultTypeInternal _DeviceMonitorSharedMemoryKey_default_instance_;
class DeviceStateJson;
struct DeviceStateJsonDefaultTypeInternal;
extern DeviceStateJsonDefaultTypeInternal _DeviceStateJson_default_instance_;
class DeviceStatus;
struct DeviceStatusDefaultTypeInternal;
extern DeviceStatusDefaultTypeInternal _DeviceStatus_default_instance_;
class DeviceVolumnInfo;
struct DeviceVolumnInfoDefaultTypeInternal;
extern DeviceVolumnInfoDefaultTypeInternal _DeviceVolumnInfo_default_instance_;
class PicPlayInfo;
struct PicPlayInfoDefaultTypeInternal;
extern PicPlayInfoDefaultTypeInternal _PicPlayInfo_default_instance_;
class RoomBytesInfo;
struct RoomBytesInfoDefaultTypeInternal;
extern RoomBytesInfoDefaultTypeInternal _RoomBytesInfo_default_instance_;
class ScreenMonitorParameter;
struct ScreenMonitorParameterDefaultTypeInternal;
extern ScreenMonitorParameterDefaultTypeInternal _ScreenMonitorParameter_default_instance_;
class ScreenStateInfo;
struct ScreenStateInfoDefaultTypeInternal;
extern ScreenStateInfoDefaultTypeInternal _ScreenStateInfo_default_instance_;
class ServerFeedback;
struct ServerFeedbackDefaultTypeInternal;
extern ServerFeedbackDefaultTypeInternal _ServerFeedback_default_instance_;
class TexHandleInfo;
struct TexHandleInfoDefaultTypeInternal;
extern TexHandleInfoDefaultTypeInternal _TexHandleInfo_default_instance_;
class VRPid;
struct VRPidDefaultTypeInternal;
extern VRPidDefaultTypeInternal _VRPid_default_instance_;
class VideoControlResult;
struct VideoControlResultDefaultTypeInternal;
extern VideoControlResultDefaultTypeInternal _VideoControlResult_default_instance_;
class VideoFrameInfo;
struct VideoFrameInfoDefaultTypeInternal;
extern VideoFrameInfoDefaultTypeInternal _VideoFrameInfo_default_instance_;
class VideoPlayInfo;
struct VideoPlayInfoDefaultTypeInternal;
extern VideoPlayInfoDefaultTypeInternal _VideoPlayInfo_default_instance_;
class VideoSeekInfo;
struct VideoSeekInfoDefaultTypeInternal;
extern VideoSeekInfoDefaultTypeInternal _VideoSeekInfo_default_instance_;
class VrParam;
struct VrParamDefaultTypeInternal;
extern VrParamDefaultTypeInternal _VrParam_default_instance_;
}  // namespace PXREAService
PROTOBUF_NAMESPACE_OPEN
template<> ::PXREAService::AppPlayInfo* Arena::CreateMaybeMessage<::PXREAService::AppPlayInfo>(Arena*);
template<> ::PXREAService::ControllerBattery* Arena::CreateMaybeMessage<::PXREAService::ControllerBattery>(Arena*);
template<> ::PXREAService::ControllerHomeButtonFunction* Arena::CreateMaybeMessage<::PXREAService::ControllerHomeButtonFunction>(Arena*);
template<> ::PXREAService::ControllerInfo* Arena::CreateMaybeMessage<::PXREAService::ControllerInfo>(Arena*);
template<> ::PXREAService::CurrentApplication* Arena::CreateMaybeMessage<::PXREAService::CurrentApplication>(Arena*);
template<> ::PXREAService::DeviceAliasInfo* Arena::CreateMaybeMessage<::PXREAService::DeviceAliasInfo>(Arena*);
template<> ::PXREAService::DeviceBattery* Arena::CreateMaybeMessage<::PXREAService::DeviceBattery>(Arena*);
template<> ::PXREAService::DeviceBlob* Arena::CreateMaybeMessage<::PXREAService::DeviceBlob>(Arena*);
template<> ::PXREAService::DeviceBytesInfo* Arena::CreateMaybeMessage<::PXREAService::DeviceBytesInfo>(Arena*);
template<> ::PXREAService::DeviceControlParameterJson* Arena::CreateMaybeMessage<::PXREAService::DeviceControlParameterJson>(Arena*);
template<> ::PXREAService::DeviceID* Arena::CreateMaybeMessage<::PXREAService::DeviceID>(Arena*);
template<> ::PXREAService::DeviceModel* Arena::CreateMaybeMessage<::PXREAService::DeviceModel>(Arena*);
template<> ::PXREAService::DeviceMonitorParameter* Arena::CreateMaybeMessage<::PXREAService::DeviceMonitorParameter>(Arena*);
template<> ::PXREAService::DeviceMonitorSharedMemoryKey* Arena::CreateMaybeMessage<::PXREAService::DeviceMonitorSharedMemoryKey>(Arena*);
template<> ::PXREAService::DeviceStateJson* Arena::CreateMaybeMessage<::PXREAService::DeviceStateJson>(Arena*);
template<> ::PXREAService::DeviceStatus* Arena::CreateMaybeMessage<::PXREAService::DeviceStatus>(Arena*);
template<> ::PXREAService::DeviceVolumnInfo* Arena::CreateMaybeMessage<::PXREAService::DeviceVolumnInfo>(Arena*);
template<> ::PXREAService::PicPlayInfo* Arena::CreateMaybeMessage<::PXREAService::PicPlayInfo>(Arena*);
template<> ::PXREAService::RoomBytesInfo* Arena::CreateMaybeMessage<::PXREAService::RoomBytesInfo>(Arena*);
template<> ::PXREAService::ScreenMonitorParameter* Arena::CreateMaybeMessage<::PXREAService::ScreenMonitorParameter>(Arena*);
template<> ::PXREAService::ScreenStateInfo* Arena::CreateMaybeMessage<::PXREAService::ScreenStateInfo>(Arena*);
template<> ::PXREAService::ServerFeedback* Arena::CreateMaybeMessage<::PXREAService::ServerFeedback>(Arena*);
template<> ::PXREAService::TexHandleInfo* Arena::CreateMaybeMessage<::PXREAService::TexHandleInfo>(Arena*);
template<> ::PXREAService::VRPid* Arena::CreateMaybeMessage<::PXREAService::VRPid>(Arena*);
template<> ::PXREAService::VideoControlResult* Arena::CreateMaybeMessage<::PXREAService::VideoControlResult>(Arena*);
template<> ::PXREAService::VideoFrameInfo* Arena::CreateMaybeMessage<::PXREAService::VideoFrameInfo>(Arena*);
template<> ::PXREAService::VideoPlayInfo* Arena::CreateMaybeMessage<::PXREAService::VideoPlayInfo>(Arena*);
template<> ::PXREAService::VideoSeekInfo* Arena::CreateMaybeMessage<::PXREAService::VideoSeekInfo>(Arena*);
template<> ::PXREAService::VrParam* Arena::CreateMaybeMessage<::PXREAService::VrParam>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PXREAService {

// ===================================================================

class DeviceID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceID) */ {
 public:
  inline DeviceID() : DeviceID(nullptr) {}
  ~DeviceID() override;
  explicit constexpr DeviceID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceID(const DeviceID& from);
  DeviceID(DeviceID&& from) noexcept
    : DeviceID() {
    *this = ::std::move(from);
  }

  inline DeviceID& operator=(const DeviceID& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceID& operator=(DeviceID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceID& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceID* internal_default_instance() {
    return reinterpret_cast<const DeviceID*>(
               &_DeviceID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceID& a, DeviceID& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceID* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceID* New() const final {
    return new DeviceID();
  }

  DeviceID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceID";
  }
  protected:
  explicit DeviceID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class VRPid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.VRPid) */ {
 public:
  inline VRPid() : VRPid(nullptr) {}
  ~VRPid() override;
  explicit constexpr VRPid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VRPid(const VRPid& from);
  VRPid(VRPid&& from) noexcept
    : VRPid() {
    *this = ::std::move(from);
  }

  inline VRPid& operator=(const VRPid& from) {
    CopyFrom(from);
    return *this;
  }
  inline VRPid& operator=(VRPid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VRPid& default_instance() {
    return *internal_default_instance();
  }
  static inline const VRPid* internal_default_instance() {
    return reinterpret_cast<const VRPid*>(
               &_VRPid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VRPid& a, VRPid& b) {
    a.Swap(&b);
  }
  inline void Swap(VRPid* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VRPid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VRPid* New() const final {
    return new VRPid();
  }

  VRPid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VRPid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VRPid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VRPid& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VRPid* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.VRPid";
  }
  protected:
  explicit VRPid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // int32 pid = 1;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.VRPid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class TexHandleInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.TexHandleInfo) */ {
 public:
  inline TexHandleInfo() : TexHandleInfo(nullptr) {}
  ~TexHandleInfo() override;
  explicit constexpr TexHandleInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TexHandleInfo(const TexHandleInfo& from);
  TexHandleInfo(TexHandleInfo&& from) noexcept
    : TexHandleInfo() {
    *this = ::std::move(from);
  }

  inline TexHandleInfo& operator=(const TexHandleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TexHandleInfo& operator=(TexHandleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TexHandleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TexHandleInfo* internal_default_instance() {
    return reinterpret_cast<const TexHandleInfo*>(
               &_TexHandleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TexHandleInfo& a, TexHandleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TexHandleInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TexHandleInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TexHandleInfo* New() const final {
    return new TexHandleInfo();
  }

  TexHandleInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TexHandleInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TexHandleInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TexHandleInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TexHandleInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.TexHandleInfo";
  }
  protected:
  explicit TexHandleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kHandleFieldNumber = 2,
  };
  // int64 pid = 1;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 handle = 2;
  void clear_handle();
  ::PROTOBUF_NAMESPACE_ID::int64 handle() const;
  void set_handle(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_handle() const;
  void _internal_set_handle(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.TexHandleInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  ::PROTOBUF_NAMESPACE_ID::int64 handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class VideoPlayInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.VideoPlayInfo) */ {
 public:
  inline VideoPlayInfo() : VideoPlayInfo(nullptr) {}
  ~VideoPlayInfo() override;
  explicit constexpr VideoPlayInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoPlayInfo(const VideoPlayInfo& from);
  VideoPlayInfo(VideoPlayInfo&& from) noexcept
    : VideoPlayInfo() {
    *this = ::std::move(from);
  }

  inline VideoPlayInfo& operator=(const VideoPlayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoPlayInfo& operator=(VideoPlayInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoPlayInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoPlayInfo* internal_default_instance() {
    return reinterpret_cast<const VideoPlayInfo*>(
               &_VideoPlayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VideoPlayInfo& a, VideoPlayInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoPlayInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoPlayInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoPlayInfo* New() const final {
    return new VideoPlayInfo();
  }

  VideoPlayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoPlayInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoPlayInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VideoPlayInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoPlayInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.VideoPlayInfo";
  }
  protected:
  explicit VideoPlayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kVideopathFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string videopath = 2;
  void clear_videopath();
  const std::string& videopath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_videopath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_videopath();
  PROTOBUF_MUST_USE_RESULT std::string* release_videopath();
  void set_allocated_videopath(std::string* videopath);
  private:
  const std::string& _internal_videopath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_videopath(const std::string& value);
  std::string* _internal_mutable_videopath();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.VideoPlayInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr videopath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class VideoSeekInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.VideoSeekInfo) */ {
 public:
  inline VideoSeekInfo() : VideoSeekInfo(nullptr) {}
  ~VideoSeekInfo() override;
  explicit constexpr VideoSeekInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoSeekInfo(const VideoSeekInfo& from);
  VideoSeekInfo(VideoSeekInfo&& from) noexcept
    : VideoSeekInfo() {
    *this = ::std::move(from);
  }

  inline VideoSeekInfo& operator=(const VideoSeekInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoSeekInfo& operator=(VideoSeekInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoSeekInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoSeekInfo* internal_default_instance() {
    return reinterpret_cast<const VideoSeekInfo*>(
               &_VideoSeekInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VideoSeekInfo& a, VideoSeekInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoSeekInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoSeekInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoSeekInfo* New() const final {
    return new VideoSeekInfo();
  }

  VideoSeekInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoSeekInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoSeekInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VideoSeekInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoSeekInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.VideoSeekInfo";
  }
  protected:
  explicit VideoSeekInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kMillisecondFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // int32 millisecond = 2;
  void clear_millisecond();
  ::PROTOBUF_NAMESPACE_ID::int32 millisecond() const;
  void set_millisecond(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_millisecond() const;
  void _internal_set_millisecond(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.VideoSeekInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::int32 millisecond_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class AppPlayInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.AppPlayInfo) */ {
 public:
  inline AppPlayInfo() : AppPlayInfo(nullptr) {}
  ~AppPlayInfo() override;
  explicit constexpr AppPlayInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppPlayInfo(const AppPlayInfo& from);
  AppPlayInfo(AppPlayInfo&& from) noexcept
    : AppPlayInfo() {
    *this = ::std::move(from);
  }

  inline AppPlayInfo& operator=(const AppPlayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppPlayInfo& operator=(AppPlayInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppPlayInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppPlayInfo* internal_default_instance() {
    return reinterpret_cast<const AppPlayInfo*>(
               &_AppPlayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AppPlayInfo& a, AppPlayInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppPlayInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppPlayInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppPlayInfo* New() const final {
    return new AppPlayInfo();
  }

  AppPlayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppPlayInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppPlayInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppPlayInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppPlayInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.AppPlayInfo";
  }
  protected:
  explicit AppPlayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kAppnameFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string appname = 2;
  void clear_appname();
  const std::string& appname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appname();
  PROTOBUF_MUST_USE_RESULT std::string* release_appname();
  void set_allocated_appname(std::string* appname);
  private:
  const std::string& _internal_appname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appname(const std::string& value);
  std::string* _internal_mutable_appname();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.AppPlayInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class PicPlayInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.PicPlayInfo) */ {
 public:
  inline PicPlayInfo() : PicPlayInfo(nullptr) {}
  ~PicPlayInfo() override;
  explicit constexpr PicPlayInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PicPlayInfo(const PicPlayInfo& from);
  PicPlayInfo(PicPlayInfo&& from) noexcept
    : PicPlayInfo() {
    *this = ::std::move(from);
  }

  inline PicPlayInfo& operator=(const PicPlayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PicPlayInfo& operator=(PicPlayInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PicPlayInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PicPlayInfo* internal_default_instance() {
    return reinterpret_cast<const PicPlayInfo*>(
               &_PicPlayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PicPlayInfo& a, PicPlayInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PicPlayInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PicPlayInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PicPlayInfo* New() const final {
    return new PicPlayInfo();
  }

  PicPlayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PicPlayInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PicPlayInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PicPlayInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PicPlayInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.PicPlayInfo";
  }
  protected:
  explicit PicPlayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kPicpathFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string picpath = 2;
  void clear_picpath();
  const std::string& picpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_picpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_picpath();
  PROTOBUF_MUST_USE_RESULT std::string* release_picpath();
  void set_allocated_picpath(std::string* picpath);
  private:
  const std::string& _internal_picpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picpath(const std::string& value);
  std::string* _internal_mutable_picpath();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.PicPlayInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr picpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceVolumnInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceVolumnInfo) */ {
 public:
  inline DeviceVolumnInfo() : DeviceVolumnInfo(nullptr) {}
  ~DeviceVolumnInfo() override;
  explicit constexpr DeviceVolumnInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceVolumnInfo(const DeviceVolumnInfo& from);
  DeviceVolumnInfo(DeviceVolumnInfo&& from) noexcept
    : DeviceVolumnInfo() {
    *this = ::std::move(from);
  }

  inline DeviceVolumnInfo& operator=(const DeviceVolumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceVolumnInfo& operator=(DeviceVolumnInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceVolumnInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceVolumnInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceVolumnInfo*>(
               &_DeviceVolumnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeviceVolumnInfo& a, DeviceVolumnInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceVolumnInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceVolumnInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceVolumnInfo* New() const final {
    return new DeviceVolumnInfo();
  }

  DeviceVolumnInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceVolumnInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceVolumnInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceVolumnInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceVolumnInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceVolumnInfo";
  }
  protected:
  explicit DeviceVolumnInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kVolumnFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // uint32 volumn = 2;
  void clear_volumn();
  ::PROTOBUF_NAMESPACE_ID::uint32 volumn() const;
  void set_volumn(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_volumn() const;
  void _internal_set_volumn(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceVolumnInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volumn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceBytesInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceBytesInfo) */ {
 public:
  inline DeviceBytesInfo() : DeviceBytesInfo(nullptr) {}
  ~DeviceBytesInfo() override;
  explicit constexpr DeviceBytesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceBytesInfo(const DeviceBytesInfo& from);
  DeviceBytesInfo(DeviceBytesInfo&& from) noexcept
    : DeviceBytesInfo() {
    *this = ::std::move(from);
  }

  inline DeviceBytesInfo& operator=(const DeviceBytesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceBytesInfo& operator=(DeviceBytesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceBytesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceBytesInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceBytesInfo*>(
               &_DeviceBytesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeviceBytesInfo& a, DeviceBytesInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceBytesInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceBytesInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceBytesInfo* New() const final {
    return new DeviceBytesInfo();
  }

  DeviceBytesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceBytesInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceBytesInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceBytesInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceBytesInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceBytesInfo";
  }
  protected:
  explicit DeviceBytesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_MUST_USE_RESULT std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceBytesInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class RoomBytesInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.RoomBytesInfo) */ {
 public:
  inline RoomBytesInfo() : RoomBytesInfo(nullptr) {}
  ~RoomBytesInfo() override;
  explicit constexpr RoomBytesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomBytesInfo(const RoomBytesInfo& from);
  RoomBytesInfo(RoomBytesInfo&& from) noexcept
    : RoomBytesInfo() {
    *this = ::std::move(from);
  }

  inline RoomBytesInfo& operator=(const RoomBytesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomBytesInfo& operator=(RoomBytesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomBytesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomBytesInfo* internal_default_instance() {
    return reinterpret_cast<const RoomBytesInfo*>(
               &_RoomBytesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoomBytesInfo& a, RoomBytesInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomBytesInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomBytesInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomBytesInfo* New() const final {
    return new RoomBytesInfo();
  }

  RoomBytesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomBytesInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomBytesInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomBytesInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomBytesInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.RoomBytesInfo";
  }
  protected:
  explicit RoomBytesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // bytes content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_MUST_USE_RESULT std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.RoomBytesInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class ControllerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.ControllerInfo) */ {
 public:
  inline ControllerInfo() : ControllerInfo(nullptr) {}
  ~ControllerInfo() override;
  explicit constexpr ControllerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControllerInfo(const ControllerInfo& from);
  ControllerInfo(ControllerInfo&& from) noexcept
    : ControllerInfo() {
    *this = ::std::move(from);
  }

  inline ControllerInfo& operator=(const ControllerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerInfo& operator=(ControllerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerInfo* internal_default_instance() {
    return reinterpret_cast<const ControllerInfo*>(
               &_ControllerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ControllerInfo& a, ControllerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerInfo* New() const final {
    return new ControllerInfo();
  }

  ControllerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControllerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControllerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.ControllerInfo";
  }
  protected:
  explicit ControllerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kControlleridFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // int32 controllerid = 2;
  void clear_controllerid();
  ::PROTOBUF_NAMESPACE_ID::int32 controllerid() const;
  void set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_controllerid() const;
  void _internal_set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.ControllerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::int32 controllerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class ControllerHomeButtonFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.ControllerHomeButtonFunction) */ {
 public:
  inline ControllerHomeButtonFunction() : ControllerHomeButtonFunction(nullptr) {}
  ~ControllerHomeButtonFunction() override;
  explicit constexpr ControllerHomeButtonFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControllerHomeButtonFunction(const ControllerHomeButtonFunction& from);
  ControllerHomeButtonFunction(ControllerHomeButtonFunction&& from) noexcept
    : ControllerHomeButtonFunction() {
    *this = ::std::move(from);
  }

  inline ControllerHomeButtonFunction& operator=(const ControllerHomeButtonFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerHomeButtonFunction& operator=(ControllerHomeButtonFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerHomeButtonFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerHomeButtonFunction* internal_default_instance() {
    return reinterpret_cast<const ControllerHomeButtonFunction*>(
               &_ControllerHomeButtonFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ControllerHomeButtonFunction& a, ControllerHomeButtonFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerHomeButtonFunction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerHomeButtonFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerHomeButtonFunction* New() const final {
    return new ControllerHomeButtonFunction();
  }

  ControllerHomeButtonFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerHomeButtonFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControllerHomeButtonFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControllerHomeButtonFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerHomeButtonFunction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.ControllerHomeButtonFunction";
  }
  protected:
  explicit ControllerHomeButtonFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kHomebuttontypeFieldNumber = 2,
    kHomefunctionFieldNumber = 3,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string homebuttontype = 2;
  void clear_homebuttontype();
  const std::string& homebuttontype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_homebuttontype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_homebuttontype();
  PROTOBUF_MUST_USE_RESULT std::string* release_homebuttontype();
  void set_allocated_homebuttontype(std::string* homebuttontype);
  private:
  const std::string& _internal_homebuttontype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_homebuttontype(const std::string& value);
  std::string* _internal_mutable_homebuttontype();
  public:

  // string homefunction = 3;
  void clear_homefunction();
  const std::string& homefunction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_homefunction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_homefunction();
  PROTOBUF_MUST_USE_RESULT std::string* release_homefunction();
  void set_allocated_homefunction(std::string* homefunction);
  private:
  const std::string& _internal_homefunction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_homefunction(const std::string& value);
  std::string* _internal_mutable_homefunction();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.ControllerHomeButtonFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homebuttontype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homefunction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class ScreenStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.ScreenStateInfo) */ {
 public:
  inline ScreenStateInfo() : ScreenStateInfo(nullptr) {}
  ~ScreenStateInfo() override;
  explicit constexpr ScreenStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScreenStateInfo(const ScreenStateInfo& from);
  ScreenStateInfo(ScreenStateInfo&& from) noexcept
    : ScreenStateInfo() {
    *this = ::std::move(from);
  }

  inline ScreenStateInfo& operator=(const ScreenStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScreenStateInfo& operator=(ScreenStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScreenStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScreenStateInfo* internal_default_instance() {
    return reinterpret_cast<const ScreenStateInfo*>(
               &_ScreenStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ScreenStateInfo& a, ScreenStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ScreenStateInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScreenStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScreenStateInfo* New() const final {
    return new ScreenStateInfo();
  }

  ScreenStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScreenStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScreenStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScreenStateInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScreenStateInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.ScreenStateInfo";
  }
  protected:
  explicit ScreenStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // int32 state = 2;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::int32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.ScreenStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceAliasInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceAliasInfo) */ {
 public:
  inline DeviceAliasInfo() : DeviceAliasInfo(nullptr) {}
  ~DeviceAliasInfo() override;
  explicit constexpr DeviceAliasInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAliasInfo(const DeviceAliasInfo& from);
  DeviceAliasInfo(DeviceAliasInfo&& from) noexcept
    : DeviceAliasInfo() {
    *this = ::std::move(from);
  }

  inline DeviceAliasInfo& operator=(const DeviceAliasInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAliasInfo& operator=(DeviceAliasInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceAliasInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAliasInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceAliasInfo*>(
               &_DeviceAliasInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeviceAliasInfo& a, DeviceAliasInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAliasInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAliasInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceAliasInfo* New() const final {
    return new DeviceAliasInfo();
  }

  DeviceAliasInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceAliasInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceAliasInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceAliasInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceAliasInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceAliasInfo";
  }
  protected:
  explicit DeviceAliasInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kAliasFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string alias = 2;
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_MUST_USE_RESULT std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceAliasInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class ServerFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.ServerFeedback) */ {
 public:
  inline ServerFeedback() : ServerFeedback(nullptr) {}
  ~ServerFeedback() override;
  explicit constexpr ServerFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerFeedback(const ServerFeedback& from);
  ServerFeedback(ServerFeedback&& from) noexcept
    : ServerFeedback() {
    *this = ::std::move(from);
  }

  inline ServerFeedback& operator=(const ServerFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerFeedback& operator=(ServerFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerFeedback& default_instance() {
    return *internal_default_instance();
  }
  enum FeedbackArgsCase {
    kVrparam = 2,
    kDevid = 3,
    kDevbattery = 4,
    kDevstatus = 5,
    kDevblob = 6,
    kDevmonitorpara = 7,
    kDevmodel = 8,
    kCurrentapp = 9,
    kCtrllerbtry = 10,
    kVideoframeinfo = 11,
    kDevicemonitorsharedmemorykey = 12,
    kVideocontrolresult = 13,
    kDevicealiasinfo = 14,
    kDevicestatejson = 15,
    FEEDBACKARGS_NOT_SET = 0,
  };

  static inline const ServerFeedback* internal_default_instance() {
    return reinterpret_cast<const ServerFeedback*>(
               &_ServerFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ServerFeedback& a, ServerFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerFeedback* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerFeedback* New() const final {
    return new ServerFeedback();
  }

  ServerFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerFeedback& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.ServerFeedback";
  }
  protected:
  explicit ServerFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVrparamFieldNumber = 2,
    kDevidFieldNumber = 3,
    kDevbatteryFieldNumber = 4,
    kDevstatusFieldNumber = 5,
    kDevblobFieldNumber = 6,
    kDevmonitorparaFieldNumber = 7,
    kDevmodelFieldNumber = 8,
    kCurrentappFieldNumber = 9,
    kCtrllerbtryFieldNumber = 10,
    kVideoframeinfoFieldNumber = 11,
    kDevicemonitorsharedmemorykeyFieldNumber = 12,
    kVideocontrolresultFieldNumber = 13,
    kDevicealiasinfoFieldNumber = 14,
    kDevicestatejsonFieldNumber = 15,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .PXREAService.VrParam vrparam = 2;
  bool has_vrparam() const;
  private:
  bool _internal_has_vrparam() const;
  public:
  void clear_vrparam();
  const ::PXREAService::VrParam& vrparam() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::VrParam* release_vrparam();
  ::PXREAService::VrParam* mutable_vrparam();
  void set_allocated_vrparam(::PXREAService::VrParam* vrparam);
  private:
  const ::PXREAService::VrParam& _internal_vrparam() const;
  ::PXREAService::VrParam* _internal_mutable_vrparam();
  public:
  void unsafe_arena_set_allocated_vrparam(
      ::PXREAService::VrParam* vrparam);
  ::PXREAService::VrParam* unsafe_arena_release_vrparam();

  // string devid = 3;
  bool has_devid() const;
  private:
  bool _internal_has_devid() const;
  public:
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // .PXREAService.DeviceBattery devbattery = 4;
  bool has_devbattery() const;
  private:
  bool _internal_has_devbattery() const;
  public:
  void clear_devbattery();
  const ::PXREAService::DeviceBattery& devbattery() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceBattery* release_devbattery();
  ::PXREAService::DeviceBattery* mutable_devbattery();
  void set_allocated_devbattery(::PXREAService::DeviceBattery* devbattery);
  private:
  const ::PXREAService::DeviceBattery& _internal_devbattery() const;
  ::PXREAService::DeviceBattery* _internal_mutable_devbattery();
  public:
  void unsafe_arena_set_allocated_devbattery(
      ::PXREAService::DeviceBattery* devbattery);
  ::PXREAService::DeviceBattery* unsafe_arena_release_devbattery();

  // .PXREAService.DeviceStatus devstatus = 5;
  bool has_devstatus() const;
  private:
  bool _internal_has_devstatus() const;
  public:
  void clear_devstatus();
  const ::PXREAService::DeviceStatus& devstatus() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceStatus* release_devstatus();
  ::PXREAService::DeviceStatus* mutable_devstatus();
  void set_allocated_devstatus(::PXREAService::DeviceStatus* devstatus);
  private:
  const ::PXREAService::DeviceStatus& _internal_devstatus() const;
  ::PXREAService::DeviceStatus* _internal_mutable_devstatus();
  public:
  void unsafe_arena_set_allocated_devstatus(
      ::PXREAService::DeviceStatus* devstatus);
  ::PXREAService::DeviceStatus* unsafe_arena_release_devstatus();

  // .PXREAService.DeviceBlob devblob = 6;
  bool has_devblob() const;
  private:
  bool _internal_has_devblob() const;
  public:
  void clear_devblob();
  const ::PXREAService::DeviceBlob& devblob() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceBlob* release_devblob();
  ::PXREAService::DeviceBlob* mutable_devblob();
  void set_allocated_devblob(::PXREAService::DeviceBlob* devblob);
  private:
  const ::PXREAService::DeviceBlob& _internal_devblob() const;
  ::PXREAService::DeviceBlob* _internal_mutable_devblob();
  public:
  void unsafe_arena_set_allocated_devblob(
      ::PXREAService::DeviceBlob* devblob);
  ::PXREAService::DeviceBlob* unsafe_arena_release_devblob();

  // .PXREAService.DeviceMonitorParameter devmonitorpara = 7;
  bool has_devmonitorpara() const;
  private:
  bool _internal_has_devmonitorpara() const;
  public:
  void clear_devmonitorpara();
  const ::PXREAService::DeviceMonitorParameter& devmonitorpara() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceMonitorParameter* release_devmonitorpara();
  ::PXREAService::DeviceMonitorParameter* mutable_devmonitorpara();
  void set_allocated_devmonitorpara(::PXREAService::DeviceMonitorParameter* devmonitorpara);
  private:
  const ::PXREAService::DeviceMonitorParameter& _internal_devmonitorpara() const;
  ::PXREAService::DeviceMonitorParameter* _internal_mutable_devmonitorpara();
  public:
  void unsafe_arena_set_allocated_devmonitorpara(
      ::PXREAService::DeviceMonitorParameter* devmonitorpara);
  ::PXREAService::DeviceMonitorParameter* unsafe_arena_release_devmonitorpara();

  // .PXREAService.DeviceModel devmodel = 8;
  bool has_devmodel() const;
  private:
  bool _internal_has_devmodel() const;
  public:
  void clear_devmodel();
  const ::PXREAService::DeviceModel& devmodel() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceModel* release_devmodel();
  ::PXREAService::DeviceModel* mutable_devmodel();
  void set_allocated_devmodel(::PXREAService::DeviceModel* devmodel);
  private:
  const ::PXREAService::DeviceModel& _internal_devmodel() const;
  ::PXREAService::DeviceModel* _internal_mutable_devmodel();
  public:
  void unsafe_arena_set_allocated_devmodel(
      ::PXREAService::DeviceModel* devmodel);
  ::PXREAService::DeviceModel* unsafe_arena_release_devmodel();

  // .PXREAService.CurrentApplication currentapp = 9;
  bool has_currentapp() const;
  private:
  bool _internal_has_currentapp() const;
  public:
  void clear_currentapp();
  const ::PXREAService::CurrentApplication& currentapp() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::CurrentApplication* release_currentapp();
  ::PXREAService::CurrentApplication* mutable_currentapp();
  void set_allocated_currentapp(::PXREAService::CurrentApplication* currentapp);
  private:
  const ::PXREAService::CurrentApplication& _internal_currentapp() const;
  ::PXREAService::CurrentApplication* _internal_mutable_currentapp();
  public:
  void unsafe_arena_set_allocated_currentapp(
      ::PXREAService::CurrentApplication* currentapp);
  ::PXREAService::CurrentApplication* unsafe_arena_release_currentapp();

  // .PXREAService.ControllerBattery ctrllerbtry = 10;
  bool has_ctrllerbtry() const;
  private:
  bool _internal_has_ctrllerbtry() const;
  public:
  void clear_ctrllerbtry();
  const ::PXREAService::ControllerBattery& ctrllerbtry() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::ControllerBattery* release_ctrllerbtry();
  ::PXREAService::ControllerBattery* mutable_ctrllerbtry();
  void set_allocated_ctrllerbtry(::PXREAService::ControllerBattery* ctrllerbtry);
  private:
  const ::PXREAService::ControllerBattery& _internal_ctrllerbtry() const;
  ::PXREAService::ControllerBattery* _internal_mutable_ctrllerbtry();
  public:
  void unsafe_arena_set_allocated_ctrllerbtry(
      ::PXREAService::ControllerBattery* ctrllerbtry);
  ::PXREAService::ControllerBattery* unsafe_arena_release_ctrllerbtry();

  // .PXREAService.VideoFrameInfo videoframeinfo = 11;
  bool has_videoframeinfo() const;
  private:
  bool _internal_has_videoframeinfo() const;
  public:
  void clear_videoframeinfo();
  const ::PXREAService::VideoFrameInfo& videoframeinfo() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::VideoFrameInfo* release_videoframeinfo();
  ::PXREAService::VideoFrameInfo* mutable_videoframeinfo();
  void set_allocated_videoframeinfo(::PXREAService::VideoFrameInfo* videoframeinfo);
  private:
  const ::PXREAService::VideoFrameInfo& _internal_videoframeinfo() const;
  ::PXREAService::VideoFrameInfo* _internal_mutable_videoframeinfo();
  public:
  void unsafe_arena_set_allocated_videoframeinfo(
      ::PXREAService::VideoFrameInfo* videoframeinfo);
  ::PXREAService::VideoFrameInfo* unsafe_arena_release_videoframeinfo();

  // .PXREAService.DeviceMonitorSharedMemoryKey devicemonitorsharedmemorykey = 12;
  bool has_devicemonitorsharedmemorykey() const;
  private:
  bool _internal_has_devicemonitorsharedmemorykey() const;
  public:
  void clear_devicemonitorsharedmemorykey();
  const ::PXREAService::DeviceMonitorSharedMemoryKey& devicemonitorsharedmemorykey() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceMonitorSharedMemoryKey* release_devicemonitorsharedmemorykey();
  ::PXREAService::DeviceMonitorSharedMemoryKey* mutable_devicemonitorsharedmemorykey();
  void set_allocated_devicemonitorsharedmemorykey(::PXREAService::DeviceMonitorSharedMemoryKey* devicemonitorsharedmemorykey);
  private:
  const ::PXREAService::DeviceMonitorSharedMemoryKey& _internal_devicemonitorsharedmemorykey() const;
  ::PXREAService::DeviceMonitorSharedMemoryKey* _internal_mutable_devicemonitorsharedmemorykey();
  public:
  void unsafe_arena_set_allocated_devicemonitorsharedmemorykey(
      ::PXREAService::DeviceMonitorSharedMemoryKey* devicemonitorsharedmemorykey);
  ::PXREAService::DeviceMonitorSharedMemoryKey* unsafe_arena_release_devicemonitorsharedmemorykey();

  // .PXREAService.VideoControlResult videocontrolresult = 13;
  bool has_videocontrolresult() const;
  private:
  bool _internal_has_videocontrolresult() const;
  public:
  void clear_videocontrolresult();
  const ::PXREAService::VideoControlResult& videocontrolresult() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::VideoControlResult* release_videocontrolresult();
  ::PXREAService::VideoControlResult* mutable_videocontrolresult();
  void set_allocated_videocontrolresult(::PXREAService::VideoControlResult* videocontrolresult);
  private:
  const ::PXREAService::VideoControlResult& _internal_videocontrolresult() const;
  ::PXREAService::VideoControlResult* _internal_mutable_videocontrolresult();
  public:
  void unsafe_arena_set_allocated_videocontrolresult(
      ::PXREAService::VideoControlResult* videocontrolresult);
  ::PXREAService::VideoControlResult* unsafe_arena_release_videocontrolresult();

  // .PXREAService.DeviceAliasInfo devicealiasinfo = 14;
  bool has_devicealiasinfo() const;
  private:
  bool _internal_has_devicealiasinfo() const;
  public:
  void clear_devicealiasinfo();
  const ::PXREAService::DeviceAliasInfo& devicealiasinfo() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceAliasInfo* release_devicealiasinfo();
  ::PXREAService::DeviceAliasInfo* mutable_devicealiasinfo();
  void set_allocated_devicealiasinfo(::PXREAService::DeviceAliasInfo* devicealiasinfo);
  private:
  const ::PXREAService::DeviceAliasInfo& _internal_devicealiasinfo() const;
  ::PXREAService::DeviceAliasInfo* _internal_mutable_devicealiasinfo();
  public:
  void unsafe_arena_set_allocated_devicealiasinfo(
      ::PXREAService::DeviceAliasInfo* devicealiasinfo);
  ::PXREAService::DeviceAliasInfo* unsafe_arena_release_devicealiasinfo();

  // .PXREAService.DeviceStateJson devicestatejson = 15;
  bool has_devicestatejson() const;
  private:
  bool _internal_has_devicestatejson() const;
  public:
  void clear_devicestatejson();
  const ::PXREAService::DeviceStateJson& devicestatejson() const;
  PROTOBUF_MUST_USE_RESULT ::PXREAService::DeviceStateJson* release_devicestatejson();
  ::PXREAService::DeviceStateJson* mutable_devicestatejson();
  void set_allocated_devicestatejson(::PXREAService::DeviceStateJson* devicestatejson);
  private:
  const ::PXREAService::DeviceStateJson& _internal_devicestatejson() const;
  ::PXREAService::DeviceStateJson* _internal_mutable_devicestatejson();
  public:
  void unsafe_arena_set_allocated_devicestatejson(
      ::PXREAService::DeviceStateJson* devicestatejson);
  ::PXREAService::DeviceStateJson* unsafe_arena_release_devicestatejson();

  void clear_FeedbackArgs();
  FeedbackArgsCase FeedbackArgs_case() const;
  // @@protoc_insertion_point(class_scope:PXREAService.ServerFeedback)
 private:
  class _Internal;
  void set_has_vrparam();
  void set_has_devid();
  void set_has_devbattery();
  void set_has_devstatus();
  void set_has_devblob();
  void set_has_devmonitorpara();
  void set_has_devmodel();
  void set_has_currentapp();
  void set_has_ctrllerbtry();
  void set_has_videoframeinfo();
  void set_has_devicemonitorsharedmemorykey();
  void set_has_videocontrolresult();
  void set_has_devicealiasinfo();
  void set_has_devicestatejson();

  inline bool has_FeedbackArgs() const;
  inline void clear_has_FeedbackArgs();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  union FeedbackArgsUnion {
    constexpr FeedbackArgsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PXREAService::VrParam* vrparam_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
    ::PXREAService::DeviceBattery* devbattery_;
    ::PXREAService::DeviceStatus* devstatus_;
    ::PXREAService::DeviceBlob* devblob_;
    ::PXREAService::DeviceMonitorParameter* devmonitorpara_;
    ::PXREAService::DeviceModel* devmodel_;
    ::PXREAService::CurrentApplication* currentapp_;
    ::PXREAService::ControllerBattery* ctrllerbtry_;
    ::PXREAService::VideoFrameInfo* videoframeinfo_;
    ::PXREAService::DeviceMonitorSharedMemoryKey* devicemonitorsharedmemorykey_;
    ::PXREAService::VideoControlResult* videocontrolresult_;
    ::PXREAService::DeviceAliasInfo* devicealiasinfo_;
    ::PXREAService::DeviceStateJson* devicestatejson_;
  } FeedbackArgs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class VrParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.VrParam) */ {
 public:
  inline VrParam() : VrParam(nullptr) {}
  ~VrParam() override;
  explicit constexpr VrParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VrParam(const VrParam& from);
  VrParam(VrParam&& from) noexcept
    : VrParam() {
    *this = ::std::move(from);
  }

  inline VrParam& operator=(const VrParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline VrParam& operator=(VrParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VrParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const VrParam* internal_default_instance() {
    return reinterpret_cast<const VrParam*>(
               &_VrParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VrParam& a, VrParam& b) {
    a.Swap(&b);
  }
  inline void Swap(VrParam* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VrParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VrParam* New() const final {
    return new VrParam();
  }

  VrParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VrParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VrParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VrParam& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VrParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.VrParam";
  }
  protected:
  explicit VrParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFpsFieldNumber = 3,
  };
  // uint32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 fps = 3;
  void clear_fps();
  ::PROTOBUF_NAMESPACE_ID::uint32 fps() const;
  void set_fps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_fps() const;
  void _internal_set_fps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.VrParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::uint32 fps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceBattery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceBattery) */ {
 public:
  inline DeviceBattery() : DeviceBattery(nullptr) {}
  ~DeviceBattery() override;
  explicit constexpr DeviceBattery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceBattery(const DeviceBattery& from);
  DeviceBattery(DeviceBattery&& from) noexcept
    : DeviceBattery() {
    *this = ::std::move(from);
  }

  inline DeviceBattery& operator=(const DeviceBattery& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceBattery& operator=(DeviceBattery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceBattery& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceBattery* internal_default_instance() {
    return reinterpret_cast<const DeviceBattery*>(
               &_DeviceBattery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeviceBattery& a, DeviceBattery& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceBattery* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceBattery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceBattery* New() const final {
    return new DeviceBattery();
  }

  DeviceBattery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceBattery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceBattery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceBattery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceBattery* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceBattery";
  }
  protected:
  explicit DeviceBattery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kBatteryFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // uint32 battery = 2;
  void clear_battery();
  ::PROTOBUF_NAMESPACE_ID::uint32 battery() const;
  void set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_battery() const;
  void _internal_set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceBattery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 battery_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceStatus) */ {
 public:
  inline DeviceStatus() : DeviceStatus(nullptr) {}
  ~DeviceStatus() override;
  explicit constexpr DeviceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStatus(const DeviceStatus& from);
  DeviceStatus(DeviceStatus&& from) noexcept
    : DeviceStatus() {
    *this = ::std::move(from);
  }

  inline DeviceStatus& operator=(const DeviceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStatus& operator=(DeviceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStatus* internal_default_instance() {
    return reinterpret_cast<const DeviceStatus*>(
               &_DeviceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeviceStatus& a, DeviceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceStatus* New() const final {
    return new DeviceStatus();
  }

  DeviceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceStatus";
  }
  protected:
  explicit DeviceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // int32 status = 2;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceModel) */ {
 public:
  inline DeviceModel() : DeviceModel(nullptr) {}
  ~DeviceModel() override;
  explicit constexpr DeviceModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceModel(const DeviceModel& from);
  DeviceModel(DeviceModel&& from) noexcept
    : DeviceModel() {
    *this = ::std::move(from);
  }

  inline DeviceModel& operator=(const DeviceModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceModel& operator=(DeviceModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceModel* internal_default_instance() {
    return reinterpret_cast<const DeviceModel*>(
               &_DeviceModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeviceModel& a, DeviceModel& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceModel* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceModel* New() const final {
    return new DeviceModel();
  }

  DeviceModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceModel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceModel";
  }
  protected:
  explicit DeviceModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_MUST_USE_RESULT std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class CurrentApplication final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.CurrentApplication) */ {
 public:
  inline CurrentApplication() : CurrentApplication(nullptr) {}
  ~CurrentApplication() override;
  explicit constexpr CurrentApplication(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentApplication(const CurrentApplication& from);
  CurrentApplication(CurrentApplication&& from) noexcept
    : CurrentApplication() {
    *this = ::std::move(from);
  }

  inline CurrentApplication& operator=(const CurrentApplication& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentApplication& operator=(CurrentApplication&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentApplication& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentApplication* internal_default_instance() {
    return reinterpret_cast<const CurrentApplication*>(
               &_CurrentApplication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CurrentApplication& a, CurrentApplication& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentApplication* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentApplication* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrentApplication* New() const final {
    return new CurrentApplication();
  }

  CurrentApplication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrentApplication>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentApplication& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrentApplication& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentApplication* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.CurrentApplication";
  }
  protected:
  explicit CurrentApplication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kAppnameFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string appname = 2;
  void clear_appname();
  const std::string& appname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appname();
  PROTOBUF_MUST_USE_RESULT std::string* release_appname();
  void set_allocated_appname(std::string* appname);
  private:
  const std::string& _internal_appname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appname(const std::string& value);
  std::string* _internal_mutable_appname();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.CurrentApplication)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class ControllerBattery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.ControllerBattery) */ {
 public:
  inline ControllerBattery() : ControllerBattery(nullptr) {}
  ~ControllerBattery() override;
  explicit constexpr ControllerBattery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControllerBattery(const ControllerBattery& from);
  ControllerBattery(ControllerBattery&& from) noexcept
    : ControllerBattery() {
    *this = ::std::move(from);
  }

  inline ControllerBattery& operator=(const ControllerBattery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerBattery& operator=(ControllerBattery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerBattery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerBattery* internal_default_instance() {
    return reinterpret_cast<const ControllerBattery*>(
               &_ControllerBattery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ControllerBattery& a, ControllerBattery& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerBattery* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerBattery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerBattery* New() const final {
    return new ControllerBattery();
  }

  ControllerBattery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerBattery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControllerBattery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControllerBattery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerBattery* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.ControllerBattery";
  }
  protected:
  explicit ControllerBattery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kControlleridFieldNumber = 2,
    kConnectedFieldNumber = 3,
    kBatteryFieldNumber = 4,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // int32 controllerid = 2;
  void clear_controllerid();
  ::PROTOBUF_NAMESPACE_ID::int32 controllerid() const;
  void set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_controllerid() const;
  void _internal_set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool connected = 3;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);
  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);
  public:

  // uint32 battery = 4;
  void clear_battery();
  ::PROTOBUF_NAMESPACE_ID::uint32 battery() const;
  void set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_battery() const;
  void _internal_set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.ControllerBattery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::int32 controllerid_;
  bool connected_;
  ::PROTOBUF_NAMESPACE_ID::uint32 battery_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceBlob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceBlob) */ {
 public:
  inline DeviceBlob() : DeviceBlob(nullptr) {}
  ~DeviceBlob() override;
  explicit constexpr DeviceBlob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceBlob(const DeviceBlob& from);
  DeviceBlob(DeviceBlob&& from) noexcept
    : DeviceBlob() {
    *this = ::std::move(from);
  }

  inline DeviceBlob& operator=(const DeviceBlob& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceBlob& operator=(DeviceBlob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceBlob& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceBlob* internal_default_instance() {
    return reinterpret_cast<const DeviceBlob*>(
               &_DeviceBlob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeviceBlob& a, DeviceBlob& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceBlob* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceBlob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceBlob* New() const final {
    return new DeviceBlob();
  }

  DeviceBlob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceBlob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceBlob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceBlob& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceBlob* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceBlob";
  }
  protected:
  explicit DeviceBlob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_MUST_USE_RESULT std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceBlob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceMonitorParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceMonitorParameter) */ {
 public:
  inline DeviceMonitorParameter() : DeviceMonitorParameter(nullptr) {}
  ~DeviceMonitorParameter() override;
  explicit constexpr DeviceMonitorParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMonitorParameter(const DeviceMonitorParameter& from);
  DeviceMonitorParameter(DeviceMonitorParameter&& from) noexcept
    : DeviceMonitorParameter() {
    *this = ::std::move(from);
  }

  inline DeviceMonitorParameter& operator=(const DeviceMonitorParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMonitorParameter& operator=(DeviceMonitorParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceMonitorParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMonitorParameter* internal_default_instance() {
    return reinterpret_cast<const DeviceMonitorParameter*>(
               &_DeviceMonitorParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeviceMonitorParameter& a, DeviceMonitorParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMonitorParameter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMonitorParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceMonitorParameter* New() const final {
    return new DeviceMonitorParameter();
  }

  DeviceMonitorParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceMonitorParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceMonitorParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceMonitorParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceMonitorParameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceMonitorParameter";
  }
  protected:
  explicit DeviceMonitorParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // uint32 width = 2;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 3;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceMonitorParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class VideoFrameInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.VideoFrameInfo) */ {
 public:
  inline VideoFrameInfo() : VideoFrameInfo(nullptr) {}
  ~VideoFrameInfo() override;
  explicit constexpr VideoFrameInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoFrameInfo(const VideoFrameInfo& from);
  VideoFrameInfo(VideoFrameInfo&& from) noexcept
    : VideoFrameInfo() {
    *this = ::std::move(from);
  }

  inline VideoFrameInfo& operator=(const VideoFrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoFrameInfo& operator=(VideoFrameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoFrameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoFrameInfo* internal_default_instance() {
    return reinterpret_cast<const VideoFrameInfo*>(
               &_VideoFrameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(VideoFrameInfo& a, VideoFrameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoFrameInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoFrameInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoFrameInfo* New() const final {
    return new VideoFrameInfo();
  }

  VideoFrameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoFrameInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoFrameInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VideoFrameInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoFrameInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.VideoFrameInfo";
  }
  protected:
  explicit VideoFrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kFrameSizeFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kBytesPerLineFieldNumber = 5,
    kPixFormatFieldNumber = 6,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // uint32 frameSize = 2;
  void clear_framesize();
  ::PROTOBUF_NAMESPACE_ID::uint32 framesize() const;
  void set_framesize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_framesize() const;
  void _internal_set_framesize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 4;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 bytesPerLine = 5;
  void clear_bytesperline();
  ::PROTOBUF_NAMESPACE_ID::uint32 bytesperline() const;
  void set_bytesperline(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bytesperline() const;
  void _internal_set_bytesperline(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 pixFormat = 6;
  void clear_pixformat();
  ::PROTOBUF_NAMESPACE_ID::int32 pixformat() const;
  void set_pixformat(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pixformat() const;
  void _internal_set_pixformat(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.VideoFrameInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 framesize_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bytesperline_;
  ::PROTOBUF_NAMESPACE_ID::int32 pixformat_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceMonitorSharedMemoryKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceMonitorSharedMemoryKey) */ {
 public:
  inline DeviceMonitorSharedMemoryKey() : DeviceMonitorSharedMemoryKey(nullptr) {}
  ~DeviceMonitorSharedMemoryKey() override;
  explicit constexpr DeviceMonitorSharedMemoryKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMonitorSharedMemoryKey(const DeviceMonitorSharedMemoryKey& from);
  DeviceMonitorSharedMemoryKey(DeviceMonitorSharedMemoryKey&& from) noexcept
    : DeviceMonitorSharedMemoryKey() {
    *this = ::std::move(from);
  }

  inline DeviceMonitorSharedMemoryKey& operator=(const DeviceMonitorSharedMemoryKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMonitorSharedMemoryKey& operator=(DeviceMonitorSharedMemoryKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceMonitorSharedMemoryKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMonitorSharedMemoryKey* internal_default_instance() {
    return reinterpret_cast<const DeviceMonitorSharedMemoryKey*>(
               &_DeviceMonitorSharedMemoryKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DeviceMonitorSharedMemoryKey& a, DeviceMonitorSharedMemoryKey& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMonitorSharedMemoryKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMonitorSharedMemoryKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceMonitorSharedMemoryKey* New() const final {
    return new DeviceMonitorSharedMemoryKey();
  }

  DeviceMonitorSharedMemoryKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceMonitorSharedMemoryKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceMonitorSharedMemoryKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceMonitorSharedMemoryKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceMonitorSharedMemoryKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceMonitorSharedMemoryKey";
  }
  protected:
  explicit DeviceMonitorSharedMemoryKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmkeyFieldNumber = 1,
  };
  // string smkey = 1;
  void clear_smkey();
  const std::string& smkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smkey();
  PROTOBUF_MUST_USE_RESULT std::string* release_smkey();
  void set_allocated_smkey(std::string* smkey);
  private:
  const std::string& _internal_smkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smkey(const std::string& value);
  std::string* _internal_mutable_smkey();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceMonitorSharedMemoryKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smkey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class VideoControlResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.VideoControlResult) */ {
 public:
  inline VideoControlResult() : VideoControlResult(nullptr) {}
  ~VideoControlResult() override;
  explicit constexpr VideoControlResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoControlResult(const VideoControlResult& from);
  VideoControlResult(VideoControlResult&& from) noexcept
    : VideoControlResult() {
    *this = ::std::move(from);
  }

  inline VideoControlResult& operator=(const VideoControlResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoControlResult& operator=(VideoControlResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoControlResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoControlResult* internal_default_instance() {
    return reinterpret_cast<const VideoControlResult*>(
               &_VideoControlResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(VideoControlResult& a, VideoControlResult& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoControlResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoControlResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoControlResult* New() const final {
    return new VideoControlResult();
  }

  VideoControlResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoControlResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoControlResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VideoControlResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoControlResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.VideoControlResult";
  }
  protected:
  explicit VideoControlResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kActionFieldNumber = 2,
    kDetailFieldNumber = 5,
    kResultFieldNumber = 3,
    kErrorcodeFieldNumber = 4,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string action = 2;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_MUST_USE_RESULT std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // string detail = 5;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_MUST_USE_RESULT std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // int32 result = 3;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 errorcode = 4;
  void clear_errorcode();
  ::PROTOBUF_NAMESPACE_ID::int32 errorcode() const;
  void set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_errorcode() const;
  void _internal_set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.VideoControlResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  ::PROTOBUF_NAMESPACE_ID::int32 errorcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceControlParameterJson final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceControlParameterJson) */ {
 public:
  inline DeviceControlParameterJson() : DeviceControlParameterJson(nullptr) {}
  ~DeviceControlParameterJson() override;
  explicit constexpr DeviceControlParameterJson(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceControlParameterJson(const DeviceControlParameterJson& from);
  DeviceControlParameterJson(DeviceControlParameterJson&& from) noexcept
    : DeviceControlParameterJson() {
    *this = ::std::move(from);
  }

  inline DeviceControlParameterJson& operator=(const DeviceControlParameterJson& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceControlParameterJson& operator=(DeviceControlParameterJson&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceControlParameterJson& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceControlParameterJson* internal_default_instance() {
    return reinterpret_cast<const DeviceControlParameterJson*>(
               &_DeviceControlParameterJson_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DeviceControlParameterJson& a, DeviceControlParameterJson& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceControlParameterJson* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceControlParameterJson* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceControlParameterJson* New() const final {
    return new DeviceControlParameterJson();
  }

  DeviceControlParameterJson* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceControlParameterJson>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceControlParameterJson& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceControlParameterJson& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceControlParameterJson* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceControlParameterJson";
  }
  protected:
  explicit DeviceControlParameterJson(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kParameterFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string parameter = 2;
  void clear_parameter();
  const std::string& parameter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameter();
  PROTOBUF_MUST_USE_RESULT std::string* release_parameter();
  void set_allocated_parameter(std::string* parameter);
  private:
  const std::string& _internal_parameter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter(const std::string& value);
  std::string* _internal_mutable_parameter();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceControlParameterJson)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class DeviceStateJson final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.DeviceStateJson) */ {
 public:
  inline DeviceStateJson() : DeviceStateJson(nullptr) {}
  ~DeviceStateJson() override;
  explicit constexpr DeviceStateJson(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStateJson(const DeviceStateJson& from);
  DeviceStateJson(DeviceStateJson&& from) noexcept
    : DeviceStateJson() {
    *this = ::std::move(from);
  }

  inline DeviceStateJson& operator=(const DeviceStateJson& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStateJson& operator=(DeviceStateJson&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceStateJson& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStateJson* internal_default_instance() {
    return reinterpret_cast<const DeviceStateJson*>(
               &_DeviceStateJson_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DeviceStateJson& a, DeviceStateJson& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStateJson* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStateJson* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceStateJson* New() const final {
    return new DeviceStateJson();
  }

  DeviceStateJson* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceStateJson>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceStateJson& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceStateJson& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceStateJson* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.DeviceStateJson";
  }
  protected:
  explicit DeviceStateJson(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kStatejsonFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // string statejson = 2;
  void clear_statejson();
  const std::string& statejson() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statejson(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statejson();
  PROTOBUF_MUST_USE_RESULT std::string* release_statejson();
  void set_allocated_statejson(std::string* statejson);
  private:
  const std::string& _internal_statejson() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statejson(const std::string& value);
  std::string* _internal_mutable_statejson();
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.DeviceStateJson)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statejson_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// -------------------------------------------------------------------

class ScreenMonitorParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PXREAService.ScreenMonitorParameter) */ {
 public:
  inline ScreenMonitorParameter() : ScreenMonitorParameter(nullptr) {}
  ~ScreenMonitorParameter() override;
  explicit constexpr ScreenMonitorParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScreenMonitorParameter(const ScreenMonitorParameter& from);
  ScreenMonitorParameter(ScreenMonitorParameter&& from) noexcept
    : ScreenMonitorParameter() {
    *this = ::std::move(from);
  }

  inline ScreenMonitorParameter& operator=(const ScreenMonitorParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScreenMonitorParameter& operator=(ScreenMonitorParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScreenMonitorParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScreenMonitorParameter* internal_default_instance() {
    return reinterpret_cast<const ScreenMonitorParameter*>(
               &_ScreenMonitorParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ScreenMonitorParameter& a, ScreenMonitorParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ScreenMonitorParameter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScreenMonitorParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScreenMonitorParameter* New() const final {
    return new ScreenMonitorParameter();
  }

  ScreenMonitorParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScreenMonitorParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScreenMonitorParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScreenMonitorParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScreenMonitorParameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PXREAService.ScreenMonitorParameter";
  }
  protected:
  explicit ScreenMonitorParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevidFieldNumber = 1,
    kQualityFieldNumber = 2,
  };
  // string devid = 1;
  void clear_devid();
  const std::string& devid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devid();
  PROTOBUF_MUST_USE_RESULT std::string* release_devid();
  void set_allocated_devid(std::string* devid);
  private:
  const std::string& _internal_devid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devid(const std::string& value);
  std::string* _internal_mutable_devid();
  public:

  // int32 quality = 2;
  void clear_quality();
  ::PROTOBUF_NAMESPACE_ID::int32 quality() const;
  void set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_quality() const;
  void _internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PXREAService.ScreenMonitorParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devid_;
  ::PROTOBUF_NAMESPACE_ID::int32 quality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PXREAService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceID

// string id = 1;
inline void DeviceID::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeviceID::id() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceID.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceID::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceID.id)
}
inline std::string* DeviceID::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceID.id)
  return _s;
}
inline const std::string& DeviceID::_internal_id() const {
  return id_.Get();
}
inline void DeviceID::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceID::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceID::release_id() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceID.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceID::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceID.id)
}

// -------------------------------------------------------------------

// VRPid

// int32 pid = 1;
inline void VRPid::clear_pid() {
  pid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VRPid::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VRPid::pid() const {
  // @@protoc_insertion_point(field_get:PXREAService.VRPid.pid)
  return _internal_pid();
}
inline void VRPid::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pid_ = value;
}
inline void VRPid::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:PXREAService.VRPid.pid)
}

// -------------------------------------------------------------------

// TexHandleInfo

// int64 pid = 1;
inline void TexHandleInfo::clear_pid() {
  pid_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TexHandleInfo::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TexHandleInfo::pid() const {
  // @@protoc_insertion_point(field_get:PXREAService.TexHandleInfo.pid)
  return _internal_pid();
}
inline void TexHandleInfo::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void TexHandleInfo::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:PXREAService.TexHandleInfo.pid)
}

// int64 handle = 2;
inline void TexHandleInfo::clear_handle() {
  handle_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TexHandleInfo::_internal_handle() const {
  return handle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TexHandleInfo::handle() const {
  // @@protoc_insertion_point(field_get:PXREAService.TexHandleInfo.handle)
  return _internal_handle();
}
inline void TexHandleInfo::_internal_set_handle(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  handle_ = value;
}
inline void TexHandleInfo::set_handle(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:PXREAService.TexHandleInfo.handle)
}

// -------------------------------------------------------------------

// VideoPlayInfo

// string devid = 1;
inline void VideoPlayInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& VideoPlayInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoPlayInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoPlayInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.VideoPlayInfo.devid)
}
inline std::string* VideoPlayInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.VideoPlayInfo.devid)
  return _s;
}
inline const std::string& VideoPlayInfo::_internal_devid() const {
  return devid_.Get();
}
inline void VideoPlayInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoPlayInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoPlayInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.VideoPlayInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoPlayInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.VideoPlayInfo.devid)
}

// string videopath = 2;
inline void VideoPlayInfo::clear_videopath() {
  videopath_.ClearToEmpty();
}
inline const std::string& VideoPlayInfo::videopath() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoPlayInfo.videopath)
  return _internal_videopath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoPlayInfo::set_videopath(ArgT0&& arg0, ArgT... args) {
 
 videopath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.VideoPlayInfo.videopath)
}
inline std::string* VideoPlayInfo::mutable_videopath() {
  std::string* _s = _internal_mutable_videopath();
  // @@protoc_insertion_point(field_mutable:PXREAService.VideoPlayInfo.videopath)
  return _s;
}
inline const std::string& VideoPlayInfo::_internal_videopath() const {
  return videopath_.Get();
}
inline void VideoPlayInfo::_internal_set_videopath(const std::string& value) {
  
  videopath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoPlayInfo::_internal_mutable_videopath() {
  
  return videopath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoPlayInfo::release_videopath() {
  // @@protoc_insertion_point(field_release:PXREAService.VideoPlayInfo.videopath)
  return videopath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoPlayInfo::set_allocated_videopath(std::string* videopath) {
  if (videopath != nullptr) {
    
  } else {
    
  }
  videopath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), videopath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.VideoPlayInfo.videopath)
}

// -------------------------------------------------------------------

// VideoSeekInfo

// string devid = 1;
inline void VideoSeekInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& VideoSeekInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoSeekInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoSeekInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.VideoSeekInfo.devid)
}
inline std::string* VideoSeekInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.VideoSeekInfo.devid)
  return _s;
}
inline const std::string& VideoSeekInfo::_internal_devid() const {
  return devid_.Get();
}
inline void VideoSeekInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoSeekInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoSeekInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.VideoSeekInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoSeekInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.VideoSeekInfo.devid)
}

// int32 millisecond = 2;
inline void VideoSeekInfo::clear_millisecond() {
  millisecond_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoSeekInfo::_internal_millisecond() const {
  return millisecond_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoSeekInfo::millisecond() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoSeekInfo.millisecond)
  return _internal_millisecond();
}
inline void VideoSeekInfo::_internal_set_millisecond(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  millisecond_ = value;
}
inline void VideoSeekInfo::set_millisecond(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_millisecond(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoSeekInfo.millisecond)
}

// -------------------------------------------------------------------

// AppPlayInfo

// string devid = 1;
inline void AppPlayInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& AppPlayInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.AppPlayInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppPlayInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.AppPlayInfo.devid)
}
inline std::string* AppPlayInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.AppPlayInfo.devid)
  return _s;
}
inline const std::string& AppPlayInfo::_internal_devid() const {
  return devid_.Get();
}
inline void AppPlayInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppPlayInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppPlayInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.AppPlayInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppPlayInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.AppPlayInfo.devid)
}

// string appname = 2;
inline void AppPlayInfo::clear_appname() {
  appname_.ClearToEmpty();
}
inline const std::string& AppPlayInfo::appname() const {
  // @@protoc_insertion_point(field_get:PXREAService.AppPlayInfo.appname)
  return _internal_appname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppPlayInfo::set_appname(ArgT0&& arg0, ArgT... args) {
 
 appname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.AppPlayInfo.appname)
}
inline std::string* AppPlayInfo::mutable_appname() {
  std::string* _s = _internal_mutable_appname();
  // @@protoc_insertion_point(field_mutable:PXREAService.AppPlayInfo.appname)
  return _s;
}
inline const std::string& AppPlayInfo::_internal_appname() const {
  return appname_.Get();
}
inline void AppPlayInfo::_internal_set_appname(const std::string& value) {
  
  appname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppPlayInfo::_internal_mutable_appname() {
  
  return appname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppPlayInfo::release_appname() {
  // @@protoc_insertion_point(field_release:PXREAService.AppPlayInfo.appname)
  return appname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppPlayInfo::set_allocated_appname(std::string* appname) {
  if (appname != nullptr) {
    
  } else {
    
  }
  appname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.AppPlayInfo.appname)
}

// -------------------------------------------------------------------

// PicPlayInfo

// string devid = 1;
inline void PicPlayInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& PicPlayInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.PicPlayInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PicPlayInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.PicPlayInfo.devid)
}
inline std::string* PicPlayInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.PicPlayInfo.devid)
  return _s;
}
inline const std::string& PicPlayInfo::_internal_devid() const {
  return devid_.Get();
}
inline void PicPlayInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PicPlayInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PicPlayInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.PicPlayInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PicPlayInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.PicPlayInfo.devid)
}

// string picpath = 2;
inline void PicPlayInfo::clear_picpath() {
  picpath_.ClearToEmpty();
}
inline const std::string& PicPlayInfo::picpath() const {
  // @@protoc_insertion_point(field_get:PXREAService.PicPlayInfo.picpath)
  return _internal_picpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PicPlayInfo::set_picpath(ArgT0&& arg0, ArgT... args) {
 
 picpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.PicPlayInfo.picpath)
}
inline std::string* PicPlayInfo::mutable_picpath() {
  std::string* _s = _internal_mutable_picpath();
  // @@protoc_insertion_point(field_mutable:PXREAService.PicPlayInfo.picpath)
  return _s;
}
inline const std::string& PicPlayInfo::_internal_picpath() const {
  return picpath_.Get();
}
inline void PicPlayInfo::_internal_set_picpath(const std::string& value) {
  
  picpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PicPlayInfo::_internal_mutable_picpath() {
  
  return picpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PicPlayInfo::release_picpath() {
  // @@protoc_insertion_point(field_release:PXREAService.PicPlayInfo.picpath)
  return picpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PicPlayInfo::set_allocated_picpath(std::string* picpath) {
  if (picpath != nullptr) {
    
  } else {
    
  }
  picpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), picpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.PicPlayInfo.picpath)
}

// -------------------------------------------------------------------

// DeviceVolumnInfo

// string devid = 1;
inline void DeviceVolumnInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceVolumnInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceVolumnInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceVolumnInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceVolumnInfo.devid)
}
inline std::string* DeviceVolumnInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceVolumnInfo.devid)
  return _s;
}
inline const std::string& DeviceVolumnInfo::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceVolumnInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceVolumnInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceVolumnInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceVolumnInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceVolumnInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceVolumnInfo.devid)
}

// uint32 volumn = 2;
inline void DeviceVolumnInfo::clear_volumn() {
  volumn_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceVolumnInfo::_internal_volumn() const {
  return volumn_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceVolumnInfo::volumn() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceVolumnInfo.volumn)
  return _internal_volumn();
}
inline void DeviceVolumnInfo::_internal_set_volumn(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  volumn_ = value;
}
inline void DeviceVolumnInfo::set_volumn(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_volumn(value);
  // @@protoc_insertion_point(field_set:PXREAService.DeviceVolumnInfo.volumn)
}

// -------------------------------------------------------------------

// DeviceBytesInfo

// string devid = 1;
inline void DeviceBytesInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceBytesInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceBytesInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceBytesInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceBytesInfo.devid)
}
inline std::string* DeviceBytesInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceBytesInfo.devid)
  return _s;
}
inline const std::string& DeviceBytesInfo::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceBytesInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceBytesInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceBytesInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceBytesInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceBytesInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceBytesInfo.devid)
}

// bytes content = 2;
inline void DeviceBytesInfo::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& DeviceBytesInfo::content() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceBytesInfo.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceBytesInfo::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceBytesInfo.content)
}
inline std::string* DeviceBytesInfo::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceBytesInfo.content)
  return _s;
}
inline const std::string& DeviceBytesInfo::_internal_content() const {
  return content_.Get();
}
inline void DeviceBytesInfo::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceBytesInfo::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceBytesInfo::release_content() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceBytesInfo.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceBytesInfo::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceBytesInfo.content)
}

// -------------------------------------------------------------------

// RoomBytesInfo

// bytes content = 1;
inline void RoomBytesInfo::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& RoomBytesInfo::content() const {
  // @@protoc_insertion_point(field_get:PXREAService.RoomBytesInfo.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomBytesInfo::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.RoomBytesInfo.content)
}
inline std::string* RoomBytesInfo::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:PXREAService.RoomBytesInfo.content)
  return _s;
}
inline const std::string& RoomBytesInfo::_internal_content() const {
  return content_.Get();
}
inline void RoomBytesInfo::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomBytesInfo::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomBytesInfo::release_content() {
  // @@protoc_insertion_point(field_release:PXREAService.RoomBytesInfo.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomBytesInfo::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.RoomBytesInfo.content)
}

// -------------------------------------------------------------------

// ControllerInfo

// string devid = 1;
inline void ControllerInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& ControllerInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControllerInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ControllerInfo.devid)
}
inline std::string* ControllerInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.ControllerInfo.devid)
  return _s;
}
inline const std::string& ControllerInfo::_internal_devid() const {
  return devid_.Get();
}
inline void ControllerInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControllerInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControllerInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.ControllerInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControllerInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ControllerInfo.devid)
}

// int32 controllerid = 2;
inline void ControllerInfo::clear_controllerid() {
  controllerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ControllerInfo::_internal_controllerid() const {
  return controllerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ControllerInfo::controllerid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerInfo.controllerid)
  return _internal_controllerid();
}
inline void ControllerInfo::_internal_set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  controllerid_ = value;
}
inline void ControllerInfo::set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_controllerid(value);
  // @@protoc_insertion_point(field_set:PXREAService.ControllerInfo.controllerid)
}

// -------------------------------------------------------------------

// ControllerHomeButtonFunction

// string devid = 1;
inline void ControllerHomeButtonFunction::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& ControllerHomeButtonFunction::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerHomeButtonFunction.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControllerHomeButtonFunction::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ControllerHomeButtonFunction.devid)
}
inline std::string* ControllerHomeButtonFunction::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.ControllerHomeButtonFunction.devid)
  return _s;
}
inline const std::string& ControllerHomeButtonFunction::_internal_devid() const {
  return devid_.Get();
}
inline void ControllerHomeButtonFunction::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControllerHomeButtonFunction::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControllerHomeButtonFunction::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.ControllerHomeButtonFunction.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControllerHomeButtonFunction::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ControllerHomeButtonFunction.devid)
}

// string homebuttontype = 2;
inline void ControllerHomeButtonFunction::clear_homebuttontype() {
  homebuttontype_.ClearToEmpty();
}
inline const std::string& ControllerHomeButtonFunction::homebuttontype() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerHomeButtonFunction.homebuttontype)
  return _internal_homebuttontype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControllerHomeButtonFunction::set_homebuttontype(ArgT0&& arg0, ArgT... args) {
 
 homebuttontype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ControllerHomeButtonFunction.homebuttontype)
}
inline std::string* ControllerHomeButtonFunction::mutable_homebuttontype() {
  std::string* _s = _internal_mutable_homebuttontype();
  // @@protoc_insertion_point(field_mutable:PXREAService.ControllerHomeButtonFunction.homebuttontype)
  return _s;
}
inline const std::string& ControllerHomeButtonFunction::_internal_homebuttontype() const {
  return homebuttontype_.Get();
}
inline void ControllerHomeButtonFunction::_internal_set_homebuttontype(const std::string& value) {
  
  homebuttontype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControllerHomeButtonFunction::_internal_mutable_homebuttontype() {
  
  return homebuttontype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControllerHomeButtonFunction::release_homebuttontype() {
  // @@protoc_insertion_point(field_release:PXREAService.ControllerHomeButtonFunction.homebuttontype)
  return homebuttontype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControllerHomeButtonFunction::set_allocated_homebuttontype(std::string* homebuttontype) {
  if (homebuttontype != nullptr) {
    
  } else {
    
  }
  homebuttontype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), homebuttontype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ControllerHomeButtonFunction.homebuttontype)
}

// string homefunction = 3;
inline void ControllerHomeButtonFunction::clear_homefunction() {
  homefunction_.ClearToEmpty();
}
inline const std::string& ControllerHomeButtonFunction::homefunction() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerHomeButtonFunction.homefunction)
  return _internal_homefunction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControllerHomeButtonFunction::set_homefunction(ArgT0&& arg0, ArgT... args) {
 
 homefunction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ControllerHomeButtonFunction.homefunction)
}
inline std::string* ControllerHomeButtonFunction::mutable_homefunction() {
  std::string* _s = _internal_mutable_homefunction();
  // @@protoc_insertion_point(field_mutable:PXREAService.ControllerHomeButtonFunction.homefunction)
  return _s;
}
inline const std::string& ControllerHomeButtonFunction::_internal_homefunction() const {
  return homefunction_.Get();
}
inline void ControllerHomeButtonFunction::_internal_set_homefunction(const std::string& value) {
  
  homefunction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControllerHomeButtonFunction::_internal_mutable_homefunction() {
  
  return homefunction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControllerHomeButtonFunction::release_homefunction() {
  // @@protoc_insertion_point(field_release:PXREAService.ControllerHomeButtonFunction.homefunction)
  return homefunction_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControllerHomeButtonFunction::set_allocated_homefunction(std::string* homefunction) {
  if (homefunction != nullptr) {
    
  } else {
    
  }
  homefunction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), homefunction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ControllerHomeButtonFunction.homefunction)
}

// -------------------------------------------------------------------

// ScreenStateInfo

// string devid = 1;
inline void ScreenStateInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& ScreenStateInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ScreenStateInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScreenStateInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ScreenStateInfo.devid)
}
inline std::string* ScreenStateInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.ScreenStateInfo.devid)
  return _s;
}
inline const std::string& ScreenStateInfo::_internal_devid() const {
  return devid_.Get();
}
inline void ScreenStateInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ScreenStateInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ScreenStateInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.ScreenStateInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ScreenStateInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ScreenStateInfo.devid)
}

// int32 state = 2;
inline void ScreenStateInfo::clear_state() {
  state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScreenStateInfo::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScreenStateInfo::state() const {
  // @@protoc_insertion_point(field_get:PXREAService.ScreenStateInfo.state)
  return _internal_state();
}
inline void ScreenStateInfo::_internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  state_ = value;
}
inline void ScreenStateInfo::set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:PXREAService.ScreenStateInfo.state)
}

// -------------------------------------------------------------------

// DeviceAliasInfo

// string devid = 1;
inline void DeviceAliasInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceAliasInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceAliasInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceAliasInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceAliasInfo.devid)
}
inline std::string* DeviceAliasInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceAliasInfo.devid)
  return _s;
}
inline const std::string& DeviceAliasInfo::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceAliasInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceAliasInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceAliasInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceAliasInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceAliasInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceAliasInfo.devid)
}

// string alias = 2;
inline void DeviceAliasInfo::clear_alias() {
  alias_.ClearToEmpty();
}
inline const std::string& DeviceAliasInfo::alias() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceAliasInfo.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceAliasInfo::set_alias(ArgT0&& arg0, ArgT... args) {
 
 alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceAliasInfo.alias)
}
inline std::string* DeviceAliasInfo::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceAliasInfo.alias)
  return _s;
}
inline const std::string& DeviceAliasInfo::_internal_alias() const {
  return alias_.Get();
}
inline void DeviceAliasInfo::_internal_set_alias(const std::string& value) {
  
  alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceAliasInfo::_internal_mutable_alias() {
  
  return alias_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceAliasInfo::release_alias() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceAliasInfo.alias)
  return alias_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceAliasInfo::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    
  } else {
    
  }
  alias_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alias,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceAliasInfo.alias)
}

// -------------------------------------------------------------------

// ServerFeedback

// string name = 1;
inline void ServerFeedback::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServerFeedback::name() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerFeedback::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ServerFeedback.name)
}
inline std::string* ServerFeedback::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.name)
  return _s;
}
inline const std::string& ServerFeedback::_internal_name() const {
  return name_.Get();
}
inline void ServerFeedback::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerFeedback::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerFeedback::release_name() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerFeedback::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ServerFeedback.name)
}

// .PXREAService.VrParam vrparam = 2;
inline bool ServerFeedback::_internal_has_vrparam() const {
  return FeedbackArgs_case() == kVrparam;
}
inline bool ServerFeedback::has_vrparam() const {
  return _internal_has_vrparam();
}
inline void ServerFeedback::set_has_vrparam() {
  _oneof_case_[0] = kVrparam;
}
inline void ServerFeedback::clear_vrparam() {
  if (_internal_has_vrparam()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.vrparam_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::VrParam* ServerFeedback::release_vrparam() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.vrparam)
  if (_internal_has_vrparam()) {
    clear_has_FeedbackArgs();
      ::PXREAService::VrParam* temp = FeedbackArgs_.vrparam_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.vrparam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::VrParam& ServerFeedback::_internal_vrparam() const {
  return _internal_has_vrparam()
      ? *FeedbackArgs_.vrparam_
      : reinterpret_cast< ::PXREAService::VrParam&>(::PXREAService::_VrParam_default_instance_);
}
inline const ::PXREAService::VrParam& ServerFeedback::vrparam() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.vrparam)
  return _internal_vrparam();
}
inline ::PXREAService::VrParam* ServerFeedback::unsafe_arena_release_vrparam() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.vrparam)
  if (_internal_has_vrparam()) {
    clear_has_FeedbackArgs();
    ::PXREAService::VrParam* temp = FeedbackArgs_.vrparam_;
    FeedbackArgs_.vrparam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_vrparam(::PXREAService::VrParam* vrparam) {
  clear_FeedbackArgs();
  if (vrparam) {
    set_has_vrparam();
    FeedbackArgs_.vrparam_ = vrparam;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.vrparam)
}
inline ::PXREAService::VrParam* ServerFeedback::_internal_mutable_vrparam() {
  if (!_internal_has_vrparam()) {
    clear_FeedbackArgs();
    set_has_vrparam();
    FeedbackArgs_.vrparam_ = CreateMaybeMessage< ::PXREAService::VrParam >(GetArenaForAllocation());
  }
  return FeedbackArgs_.vrparam_;
}
inline ::PXREAService::VrParam* ServerFeedback::mutable_vrparam() {
  ::PXREAService::VrParam* _msg = _internal_mutable_vrparam();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.vrparam)
  return _msg;
}

// string devid = 3;
inline bool ServerFeedback::_internal_has_devid() const {
  return FeedbackArgs_case() == kDevid;
}
inline bool ServerFeedback::has_devid() const {
  return _internal_has_devid();
}
inline void ServerFeedback::set_has_devid() {
  _oneof_case_[0] = kDevid;
}
inline void ServerFeedback::clear_devid() {
  if (_internal_has_devid()) {
    FeedbackArgs_.devid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_FeedbackArgs();
  }
}
inline const std::string& ServerFeedback::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline void ServerFeedback::set_devid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_devid()) {
    clear_FeedbackArgs();
    set_has_devid();
    FeedbackArgs_.devid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  FeedbackArgs_.devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ServerFeedback.devid)
}
inline std::string* ServerFeedback::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devid)
  return _s;
}
inline const std::string& ServerFeedback::_internal_devid() const {
  if (_internal_has_devid()) {
    return FeedbackArgs_.devid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ServerFeedback::_internal_set_devid(const std::string& value) {
  if (!_internal_has_devid()) {
    clear_FeedbackArgs();
    set_has_devid();
    FeedbackArgs_.devid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  FeedbackArgs_.devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerFeedback::_internal_mutable_devid() {
  if (!_internal_has_devid()) {
    clear_FeedbackArgs();
    set_has_devid();
    FeedbackArgs_.devid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return FeedbackArgs_.devid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerFeedback::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devid)
  if (_internal_has_devid()) {
    clear_has_FeedbackArgs();
    return FeedbackArgs_.devid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::set_allocated_devid(std::string* devid) {
  if (has_FeedbackArgs()) {
    clear_FeedbackArgs();
  }
  if (devid != nullptr) {
    set_has_devid();
    FeedbackArgs_.devid_.UnsafeSetDefault(devid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(devid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ServerFeedback.devid)
}

// .PXREAService.DeviceBattery devbattery = 4;
inline bool ServerFeedback::_internal_has_devbattery() const {
  return FeedbackArgs_case() == kDevbattery;
}
inline bool ServerFeedback::has_devbattery() const {
  return _internal_has_devbattery();
}
inline void ServerFeedback::set_has_devbattery() {
  _oneof_case_[0] = kDevbattery;
}
inline void ServerFeedback::clear_devbattery() {
  if (_internal_has_devbattery()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devbattery_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceBattery* ServerFeedback::release_devbattery() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devbattery)
  if (_internal_has_devbattery()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceBattery* temp = FeedbackArgs_.devbattery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devbattery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceBattery& ServerFeedback::_internal_devbattery() const {
  return _internal_has_devbattery()
      ? *FeedbackArgs_.devbattery_
      : reinterpret_cast< ::PXREAService::DeviceBattery&>(::PXREAService::_DeviceBattery_default_instance_);
}
inline const ::PXREAService::DeviceBattery& ServerFeedback::devbattery() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devbattery)
  return _internal_devbattery();
}
inline ::PXREAService::DeviceBattery* ServerFeedback::unsafe_arena_release_devbattery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devbattery)
  if (_internal_has_devbattery()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceBattery* temp = FeedbackArgs_.devbattery_;
    FeedbackArgs_.devbattery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devbattery(::PXREAService::DeviceBattery* devbattery) {
  clear_FeedbackArgs();
  if (devbattery) {
    set_has_devbattery();
    FeedbackArgs_.devbattery_ = devbattery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devbattery)
}
inline ::PXREAService::DeviceBattery* ServerFeedback::_internal_mutable_devbattery() {
  if (!_internal_has_devbattery()) {
    clear_FeedbackArgs();
    set_has_devbattery();
    FeedbackArgs_.devbattery_ = CreateMaybeMessage< ::PXREAService::DeviceBattery >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devbattery_;
}
inline ::PXREAService::DeviceBattery* ServerFeedback::mutable_devbattery() {
  ::PXREAService::DeviceBattery* _msg = _internal_mutable_devbattery();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devbattery)
  return _msg;
}

// .PXREAService.DeviceStatus devstatus = 5;
inline bool ServerFeedback::_internal_has_devstatus() const {
  return FeedbackArgs_case() == kDevstatus;
}
inline bool ServerFeedback::has_devstatus() const {
  return _internal_has_devstatus();
}
inline void ServerFeedback::set_has_devstatus() {
  _oneof_case_[0] = kDevstatus;
}
inline void ServerFeedback::clear_devstatus() {
  if (_internal_has_devstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devstatus_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceStatus* ServerFeedback::release_devstatus() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devstatus)
  if (_internal_has_devstatus()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceStatus* temp = FeedbackArgs_.devstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceStatus& ServerFeedback::_internal_devstatus() const {
  return _internal_has_devstatus()
      ? *FeedbackArgs_.devstatus_
      : reinterpret_cast< ::PXREAService::DeviceStatus&>(::PXREAService::_DeviceStatus_default_instance_);
}
inline const ::PXREAService::DeviceStatus& ServerFeedback::devstatus() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devstatus)
  return _internal_devstatus();
}
inline ::PXREAService::DeviceStatus* ServerFeedback::unsafe_arena_release_devstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devstatus)
  if (_internal_has_devstatus()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceStatus* temp = FeedbackArgs_.devstatus_;
    FeedbackArgs_.devstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devstatus(::PXREAService::DeviceStatus* devstatus) {
  clear_FeedbackArgs();
  if (devstatus) {
    set_has_devstatus();
    FeedbackArgs_.devstatus_ = devstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devstatus)
}
inline ::PXREAService::DeviceStatus* ServerFeedback::_internal_mutable_devstatus() {
  if (!_internal_has_devstatus()) {
    clear_FeedbackArgs();
    set_has_devstatus();
    FeedbackArgs_.devstatus_ = CreateMaybeMessage< ::PXREAService::DeviceStatus >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devstatus_;
}
inline ::PXREAService::DeviceStatus* ServerFeedback::mutable_devstatus() {
  ::PXREAService::DeviceStatus* _msg = _internal_mutable_devstatus();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devstatus)
  return _msg;
}

// .PXREAService.DeviceBlob devblob = 6;
inline bool ServerFeedback::_internal_has_devblob() const {
  return FeedbackArgs_case() == kDevblob;
}
inline bool ServerFeedback::has_devblob() const {
  return _internal_has_devblob();
}
inline void ServerFeedback::set_has_devblob() {
  _oneof_case_[0] = kDevblob;
}
inline void ServerFeedback::clear_devblob() {
  if (_internal_has_devblob()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devblob_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceBlob* ServerFeedback::release_devblob() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devblob)
  if (_internal_has_devblob()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceBlob* temp = FeedbackArgs_.devblob_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devblob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceBlob& ServerFeedback::_internal_devblob() const {
  return _internal_has_devblob()
      ? *FeedbackArgs_.devblob_
      : reinterpret_cast< ::PXREAService::DeviceBlob&>(::PXREAService::_DeviceBlob_default_instance_);
}
inline const ::PXREAService::DeviceBlob& ServerFeedback::devblob() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devblob)
  return _internal_devblob();
}
inline ::PXREAService::DeviceBlob* ServerFeedback::unsafe_arena_release_devblob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devblob)
  if (_internal_has_devblob()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceBlob* temp = FeedbackArgs_.devblob_;
    FeedbackArgs_.devblob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devblob(::PXREAService::DeviceBlob* devblob) {
  clear_FeedbackArgs();
  if (devblob) {
    set_has_devblob();
    FeedbackArgs_.devblob_ = devblob;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devblob)
}
inline ::PXREAService::DeviceBlob* ServerFeedback::_internal_mutable_devblob() {
  if (!_internal_has_devblob()) {
    clear_FeedbackArgs();
    set_has_devblob();
    FeedbackArgs_.devblob_ = CreateMaybeMessage< ::PXREAService::DeviceBlob >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devblob_;
}
inline ::PXREAService::DeviceBlob* ServerFeedback::mutable_devblob() {
  ::PXREAService::DeviceBlob* _msg = _internal_mutable_devblob();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devblob)
  return _msg;
}

// .PXREAService.DeviceMonitorParameter devmonitorpara = 7;
inline bool ServerFeedback::_internal_has_devmonitorpara() const {
  return FeedbackArgs_case() == kDevmonitorpara;
}
inline bool ServerFeedback::has_devmonitorpara() const {
  return _internal_has_devmonitorpara();
}
inline void ServerFeedback::set_has_devmonitorpara() {
  _oneof_case_[0] = kDevmonitorpara;
}
inline void ServerFeedback::clear_devmonitorpara() {
  if (_internal_has_devmonitorpara()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devmonitorpara_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceMonitorParameter* ServerFeedback::release_devmonitorpara() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devmonitorpara)
  if (_internal_has_devmonitorpara()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceMonitorParameter* temp = FeedbackArgs_.devmonitorpara_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devmonitorpara_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceMonitorParameter& ServerFeedback::_internal_devmonitorpara() const {
  return _internal_has_devmonitorpara()
      ? *FeedbackArgs_.devmonitorpara_
      : reinterpret_cast< ::PXREAService::DeviceMonitorParameter&>(::PXREAService::_DeviceMonitorParameter_default_instance_);
}
inline const ::PXREAService::DeviceMonitorParameter& ServerFeedback::devmonitorpara() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devmonitorpara)
  return _internal_devmonitorpara();
}
inline ::PXREAService::DeviceMonitorParameter* ServerFeedback::unsafe_arena_release_devmonitorpara() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devmonitorpara)
  if (_internal_has_devmonitorpara()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceMonitorParameter* temp = FeedbackArgs_.devmonitorpara_;
    FeedbackArgs_.devmonitorpara_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devmonitorpara(::PXREAService::DeviceMonitorParameter* devmonitorpara) {
  clear_FeedbackArgs();
  if (devmonitorpara) {
    set_has_devmonitorpara();
    FeedbackArgs_.devmonitorpara_ = devmonitorpara;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devmonitorpara)
}
inline ::PXREAService::DeviceMonitorParameter* ServerFeedback::_internal_mutable_devmonitorpara() {
  if (!_internal_has_devmonitorpara()) {
    clear_FeedbackArgs();
    set_has_devmonitorpara();
    FeedbackArgs_.devmonitorpara_ = CreateMaybeMessage< ::PXREAService::DeviceMonitorParameter >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devmonitorpara_;
}
inline ::PXREAService::DeviceMonitorParameter* ServerFeedback::mutable_devmonitorpara() {
  ::PXREAService::DeviceMonitorParameter* _msg = _internal_mutable_devmonitorpara();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devmonitorpara)
  return _msg;
}

// .PXREAService.DeviceModel devmodel = 8;
inline bool ServerFeedback::_internal_has_devmodel() const {
  return FeedbackArgs_case() == kDevmodel;
}
inline bool ServerFeedback::has_devmodel() const {
  return _internal_has_devmodel();
}
inline void ServerFeedback::set_has_devmodel() {
  _oneof_case_[0] = kDevmodel;
}
inline void ServerFeedback::clear_devmodel() {
  if (_internal_has_devmodel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devmodel_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceModel* ServerFeedback::release_devmodel() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devmodel)
  if (_internal_has_devmodel()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceModel* temp = FeedbackArgs_.devmodel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceModel& ServerFeedback::_internal_devmodel() const {
  return _internal_has_devmodel()
      ? *FeedbackArgs_.devmodel_
      : reinterpret_cast< ::PXREAService::DeviceModel&>(::PXREAService::_DeviceModel_default_instance_);
}
inline const ::PXREAService::DeviceModel& ServerFeedback::devmodel() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devmodel)
  return _internal_devmodel();
}
inline ::PXREAService::DeviceModel* ServerFeedback::unsafe_arena_release_devmodel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devmodel)
  if (_internal_has_devmodel()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceModel* temp = FeedbackArgs_.devmodel_;
    FeedbackArgs_.devmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devmodel(::PXREAService::DeviceModel* devmodel) {
  clear_FeedbackArgs();
  if (devmodel) {
    set_has_devmodel();
    FeedbackArgs_.devmodel_ = devmodel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devmodel)
}
inline ::PXREAService::DeviceModel* ServerFeedback::_internal_mutable_devmodel() {
  if (!_internal_has_devmodel()) {
    clear_FeedbackArgs();
    set_has_devmodel();
    FeedbackArgs_.devmodel_ = CreateMaybeMessage< ::PXREAService::DeviceModel >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devmodel_;
}
inline ::PXREAService::DeviceModel* ServerFeedback::mutable_devmodel() {
  ::PXREAService::DeviceModel* _msg = _internal_mutable_devmodel();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devmodel)
  return _msg;
}

// .PXREAService.CurrentApplication currentapp = 9;
inline bool ServerFeedback::_internal_has_currentapp() const {
  return FeedbackArgs_case() == kCurrentapp;
}
inline bool ServerFeedback::has_currentapp() const {
  return _internal_has_currentapp();
}
inline void ServerFeedback::set_has_currentapp() {
  _oneof_case_[0] = kCurrentapp;
}
inline void ServerFeedback::clear_currentapp() {
  if (_internal_has_currentapp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.currentapp_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::CurrentApplication* ServerFeedback::release_currentapp() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.currentapp)
  if (_internal_has_currentapp()) {
    clear_has_FeedbackArgs();
      ::PXREAService::CurrentApplication* temp = FeedbackArgs_.currentapp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.currentapp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::CurrentApplication& ServerFeedback::_internal_currentapp() const {
  return _internal_has_currentapp()
      ? *FeedbackArgs_.currentapp_
      : reinterpret_cast< ::PXREAService::CurrentApplication&>(::PXREAService::_CurrentApplication_default_instance_);
}
inline const ::PXREAService::CurrentApplication& ServerFeedback::currentapp() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.currentapp)
  return _internal_currentapp();
}
inline ::PXREAService::CurrentApplication* ServerFeedback::unsafe_arena_release_currentapp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.currentapp)
  if (_internal_has_currentapp()) {
    clear_has_FeedbackArgs();
    ::PXREAService::CurrentApplication* temp = FeedbackArgs_.currentapp_;
    FeedbackArgs_.currentapp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_currentapp(::PXREAService::CurrentApplication* currentapp) {
  clear_FeedbackArgs();
  if (currentapp) {
    set_has_currentapp();
    FeedbackArgs_.currentapp_ = currentapp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.currentapp)
}
inline ::PXREAService::CurrentApplication* ServerFeedback::_internal_mutable_currentapp() {
  if (!_internal_has_currentapp()) {
    clear_FeedbackArgs();
    set_has_currentapp();
    FeedbackArgs_.currentapp_ = CreateMaybeMessage< ::PXREAService::CurrentApplication >(GetArenaForAllocation());
  }
  return FeedbackArgs_.currentapp_;
}
inline ::PXREAService::CurrentApplication* ServerFeedback::mutable_currentapp() {
  ::PXREAService::CurrentApplication* _msg = _internal_mutable_currentapp();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.currentapp)
  return _msg;
}

// .PXREAService.ControllerBattery ctrllerbtry = 10;
inline bool ServerFeedback::_internal_has_ctrllerbtry() const {
  return FeedbackArgs_case() == kCtrllerbtry;
}
inline bool ServerFeedback::has_ctrllerbtry() const {
  return _internal_has_ctrllerbtry();
}
inline void ServerFeedback::set_has_ctrllerbtry() {
  _oneof_case_[0] = kCtrllerbtry;
}
inline void ServerFeedback::clear_ctrllerbtry() {
  if (_internal_has_ctrllerbtry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.ctrllerbtry_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::ControllerBattery* ServerFeedback::release_ctrllerbtry() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.ctrllerbtry)
  if (_internal_has_ctrllerbtry()) {
    clear_has_FeedbackArgs();
      ::PXREAService::ControllerBattery* temp = FeedbackArgs_.ctrllerbtry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.ctrllerbtry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::ControllerBattery& ServerFeedback::_internal_ctrllerbtry() const {
  return _internal_has_ctrllerbtry()
      ? *FeedbackArgs_.ctrllerbtry_
      : reinterpret_cast< ::PXREAService::ControllerBattery&>(::PXREAService::_ControllerBattery_default_instance_);
}
inline const ::PXREAService::ControllerBattery& ServerFeedback::ctrllerbtry() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.ctrllerbtry)
  return _internal_ctrllerbtry();
}
inline ::PXREAService::ControllerBattery* ServerFeedback::unsafe_arena_release_ctrllerbtry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.ctrllerbtry)
  if (_internal_has_ctrllerbtry()) {
    clear_has_FeedbackArgs();
    ::PXREAService::ControllerBattery* temp = FeedbackArgs_.ctrllerbtry_;
    FeedbackArgs_.ctrllerbtry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_ctrllerbtry(::PXREAService::ControllerBattery* ctrllerbtry) {
  clear_FeedbackArgs();
  if (ctrllerbtry) {
    set_has_ctrllerbtry();
    FeedbackArgs_.ctrllerbtry_ = ctrllerbtry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.ctrllerbtry)
}
inline ::PXREAService::ControllerBattery* ServerFeedback::_internal_mutable_ctrllerbtry() {
  if (!_internal_has_ctrllerbtry()) {
    clear_FeedbackArgs();
    set_has_ctrllerbtry();
    FeedbackArgs_.ctrllerbtry_ = CreateMaybeMessage< ::PXREAService::ControllerBattery >(GetArenaForAllocation());
  }
  return FeedbackArgs_.ctrllerbtry_;
}
inline ::PXREAService::ControllerBattery* ServerFeedback::mutable_ctrllerbtry() {
  ::PXREAService::ControllerBattery* _msg = _internal_mutable_ctrllerbtry();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.ctrllerbtry)
  return _msg;
}

// .PXREAService.VideoFrameInfo videoframeinfo = 11;
inline bool ServerFeedback::_internal_has_videoframeinfo() const {
  return FeedbackArgs_case() == kVideoframeinfo;
}
inline bool ServerFeedback::has_videoframeinfo() const {
  return _internal_has_videoframeinfo();
}
inline void ServerFeedback::set_has_videoframeinfo() {
  _oneof_case_[0] = kVideoframeinfo;
}
inline void ServerFeedback::clear_videoframeinfo() {
  if (_internal_has_videoframeinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.videoframeinfo_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::VideoFrameInfo* ServerFeedback::release_videoframeinfo() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.videoframeinfo)
  if (_internal_has_videoframeinfo()) {
    clear_has_FeedbackArgs();
      ::PXREAService::VideoFrameInfo* temp = FeedbackArgs_.videoframeinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.videoframeinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::VideoFrameInfo& ServerFeedback::_internal_videoframeinfo() const {
  return _internal_has_videoframeinfo()
      ? *FeedbackArgs_.videoframeinfo_
      : reinterpret_cast< ::PXREAService::VideoFrameInfo&>(::PXREAService::_VideoFrameInfo_default_instance_);
}
inline const ::PXREAService::VideoFrameInfo& ServerFeedback::videoframeinfo() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.videoframeinfo)
  return _internal_videoframeinfo();
}
inline ::PXREAService::VideoFrameInfo* ServerFeedback::unsafe_arena_release_videoframeinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.videoframeinfo)
  if (_internal_has_videoframeinfo()) {
    clear_has_FeedbackArgs();
    ::PXREAService::VideoFrameInfo* temp = FeedbackArgs_.videoframeinfo_;
    FeedbackArgs_.videoframeinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_videoframeinfo(::PXREAService::VideoFrameInfo* videoframeinfo) {
  clear_FeedbackArgs();
  if (videoframeinfo) {
    set_has_videoframeinfo();
    FeedbackArgs_.videoframeinfo_ = videoframeinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.videoframeinfo)
}
inline ::PXREAService::VideoFrameInfo* ServerFeedback::_internal_mutable_videoframeinfo() {
  if (!_internal_has_videoframeinfo()) {
    clear_FeedbackArgs();
    set_has_videoframeinfo();
    FeedbackArgs_.videoframeinfo_ = CreateMaybeMessage< ::PXREAService::VideoFrameInfo >(GetArenaForAllocation());
  }
  return FeedbackArgs_.videoframeinfo_;
}
inline ::PXREAService::VideoFrameInfo* ServerFeedback::mutable_videoframeinfo() {
  ::PXREAService::VideoFrameInfo* _msg = _internal_mutable_videoframeinfo();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.videoframeinfo)
  return _msg;
}

// .PXREAService.DeviceMonitorSharedMemoryKey devicemonitorsharedmemorykey = 12;
inline bool ServerFeedback::_internal_has_devicemonitorsharedmemorykey() const {
  return FeedbackArgs_case() == kDevicemonitorsharedmemorykey;
}
inline bool ServerFeedback::has_devicemonitorsharedmemorykey() const {
  return _internal_has_devicemonitorsharedmemorykey();
}
inline void ServerFeedback::set_has_devicemonitorsharedmemorykey() {
  _oneof_case_[0] = kDevicemonitorsharedmemorykey;
}
inline void ServerFeedback::clear_devicemonitorsharedmemorykey() {
  if (_internal_has_devicemonitorsharedmemorykey()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devicemonitorsharedmemorykey_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceMonitorSharedMemoryKey* ServerFeedback::release_devicemonitorsharedmemorykey() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devicemonitorsharedmemorykey)
  if (_internal_has_devicemonitorsharedmemorykey()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceMonitorSharedMemoryKey* temp = FeedbackArgs_.devicemonitorsharedmemorykey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devicemonitorsharedmemorykey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceMonitorSharedMemoryKey& ServerFeedback::_internal_devicemonitorsharedmemorykey() const {
  return _internal_has_devicemonitorsharedmemorykey()
      ? *FeedbackArgs_.devicemonitorsharedmemorykey_
      : reinterpret_cast< ::PXREAService::DeviceMonitorSharedMemoryKey&>(::PXREAService::_DeviceMonitorSharedMemoryKey_default_instance_);
}
inline const ::PXREAService::DeviceMonitorSharedMemoryKey& ServerFeedback::devicemonitorsharedmemorykey() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devicemonitorsharedmemorykey)
  return _internal_devicemonitorsharedmemorykey();
}
inline ::PXREAService::DeviceMonitorSharedMemoryKey* ServerFeedback::unsafe_arena_release_devicemonitorsharedmemorykey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devicemonitorsharedmemorykey)
  if (_internal_has_devicemonitorsharedmemorykey()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceMonitorSharedMemoryKey* temp = FeedbackArgs_.devicemonitorsharedmemorykey_;
    FeedbackArgs_.devicemonitorsharedmemorykey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devicemonitorsharedmemorykey(::PXREAService::DeviceMonitorSharedMemoryKey* devicemonitorsharedmemorykey) {
  clear_FeedbackArgs();
  if (devicemonitorsharedmemorykey) {
    set_has_devicemonitorsharedmemorykey();
    FeedbackArgs_.devicemonitorsharedmemorykey_ = devicemonitorsharedmemorykey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devicemonitorsharedmemorykey)
}
inline ::PXREAService::DeviceMonitorSharedMemoryKey* ServerFeedback::_internal_mutable_devicemonitorsharedmemorykey() {
  if (!_internal_has_devicemonitorsharedmemorykey()) {
    clear_FeedbackArgs();
    set_has_devicemonitorsharedmemorykey();
    FeedbackArgs_.devicemonitorsharedmemorykey_ = CreateMaybeMessage< ::PXREAService::DeviceMonitorSharedMemoryKey >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devicemonitorsharedmemorykey_;
}
inline ::PXREAService::DeviceMonitorSharedMemoryKey* ServerFeedback::mutable_devicemonitorsharedmemorykey() {
  ::PXREAService::DeviceMonitorSharedMemoryKey* _msg = _internal_mutable_devicemonitorsharedmemorykey();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devicemonitorsharedmemorykey)
  return _msg;
}

// .PXREAService.VideoControlResult videocontrolresult = 13;
inline bool ServerFeedback::_internal_has_videocontrolresult() const {
  return FeedbackArgs_case() == kVideocontrolresult;
}
inline bool ServerFeedback::has_videocontrolresult() const {
  return _internal_has_videocontrolresult();
}
inline void ServerFeedback::set_has_videocontrolresult() {
  _oneof_case_[0] = kVideocontrolresult;
}
inline void ServerFeedback::clear_videocontrolresult() {
  if (_internal_has_videocontrolresult()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.videocontrolresult_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::VideoControlResult* ServerFeedback::release_videocontrolresult() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.videocontrolresult)
  if (_internal_has_videocontrolresult()) {
    clear_has_FeedbackArgs();
      ::PXREAService::VideoControlResult* temp = FeedbackArgs_.videocontrolresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.videocontrolresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::VideoControlResult& ServerFeedback::_internal_videocontrolresult() const {
  return _internal_has_videocontrolresult()
      ? *FeedbackArgs_.videocontrolresult_
      : reinterpret_cast< ::PXREAService::VideoControlResult&>(::PXREAService::_VideoControlResult_default_instance_);
}
inline const ::PXREAService::VideoControlResult& ServerFeedback::videocontrolresult() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.videocontrolresult)
  return _internal_videocontrolresult();
}
inline ::PXREAService::VideoControlResult* ServerFeedback::unsafe_arena_release_videocontrolresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.videocontrolresult)
  if (_internal_has_videocontrolresult()) {
    clear_has_FeedbackArgs();
    ::PXREAService::VideoControlResult* temp = FeedbackArgs_.videocontrolresult_;
    FeedbackArgs_.videocontrolresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_videocontrolresult(::PXREAService::VideoControlResult* videocontrolresult) {
  clear_FeedbackArgs();
  if (videocontrolresult) {
    set_has_videocontrolresult();
    FeedbackArgs_.videocontrolresult_ = videocontrolresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.videocontrolresult)
}
inline ::PXREAService::VideoControlResult* ServerFeedback::_internal_mutable_videocontrolresult() {
  if (!_internal_has_videocontrolresult()) {
    clear_FeedbackArgs();
    set_has_videocontrolresult();
    FeedbackArgs_.videocontrolresult_ = CreateMaybeMessage< ::PXREAService::VideoControlResult >(GetArenaForAllocation());
  }
  return FeedbackArgs_.videocontrolresult_;
}
inline ::PXREAService::VideoControlResult* ServerFeedback::mutable_videocontrolresult() {
  ::PXREAService::VideoControlResult* _msg = _internal_mutable_videocontrolresult();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.videocontrolresult)
  return _msg;
}

// .PXREAService.DeviceAliasInfo devicealiasinfo = 14;
inline bool ServerFeedback::_internal_has_devicealiasinfo() const {
  return FeedbackArgs_case() == kDevicealiasinfo;
}
inline bool ServerFeedback::has_devicealiasinfo() const {
  return _internal_has_devicealiasinfo();
}
inline void ServerFeedback::set_has_devicealiasinfo() {
  _oneof_case_[0] = kDevicealiasinfo;
}
inline void ServerFeedback::clear_devicealiasinfo() {
  if (_internal_has_devicealiasinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devicealiasinfo_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceAliasInfo* ServerFeedback::release_devicealiasinfo() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devicealiasinfo)
  if (_internal_has_devicealiasinfo()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceAliasInfo* temp = FeedbackArgs_.devicealiasinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devicealiasinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceAliasInfo& ServerFeedback::_internal_devicealiasinfo() const {
  return _internal_has_devicealiasinfo()
      ? *FeedbackArgs_.devicealiasinfo_
      : reinterpret_cast< ::PXREAService::DeviceAliasInfo&>(::PXREAService::_DeviceAliasInfo_default_instance_);
}
inline const ::PXREAService::DeviceAliasInfo& ServerFeedback::devicealiasinfo() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devicealiasinfo)
  return _internal_devicealiasinfo();
}
inline ::PXREAService::DeviceAliasInfo* ServerFeedback::unsafe_arena_release_devicealiasinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devicealiasinfo)
  if (_internal_has_devicealiasinfo()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceAliasInfo* temp = FeedbackArgs_.devicealiasinfo_;
    FeedbackArgs_.devicealiasinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devicealiasinfo(::PXREAService::DeviceAliasInfo* devicealiasinfo) {
  clear_FeedbackArgs();
  if (devicealiasinfo) {
    set_has_devicealiasinfo();
    FeedbackArgs_.devicealiasinfo_ = devicealiasinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devicealiasinfo)
}
inline ::PXREAService::DeviceAliasInfo* ServerFeedback::_internal_mutable_devicealiasinfo() {
  if (!_internal_has_devicealiasinfo()) {
    clear_FeedbackArgs();
    set_has_devicealiasinfo();
    FeedbackArgs_.devicealiasinfo_ = CreateMaybeMessage< ::PXREAService::DeviceAliasInfo >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devicealiasinfo_;
}
inline ::PXREAService::DeviceAliasInfo* ServerFeedback::mutable_devicealiasinfo() {
  ::PXREAService::DeviceAliasInfo* _msg = _internal_mutable_devicealiasinfo();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devicealiasinfo)
  return _msg;
}

// .PXREAService.DeviceStateJson devicestatejson = 15;
inline bool ServerFeedback::_internal_has_devicestatejson() const {
  return FeedbackArgs_case() == kDevicestatejson;
}
inline bool ServerFeedback::has_devicestatejson() const {
  return _internal_has_devicestatejson();
}
inline void ServerFeedback::set_has_devicestatejson() {
  _oneof_case_[0] = kDevicestatejson;
}
inline void ServerFeedback::clear_devicestatejson() {
  if (_internal_has_devicestatejson()) {
    if (GetArenaForAllocation() == nullptr) {
      delete FeedbackArgs_.devicestatejson_;
    }
    clear_has_FeedbackArgs();
  }
}
inline ::PXREAService::DeviceStateJson* ServerFeedback::release_devicestatejson() {
  // @@protoc_insertion_point(field_release:PXREAService.ServerFeedback.devicestatejson)
  if (_internal_has_devicestatejson()) {
    clear_has_FeedbackArgs();
      ::PXREAService::DeviceStateJson* temp = FeedbackArgs_.devicestatejson_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeedbackArgs_.devicestatejson_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PXREAService::DeviceStateJson& ServerFeedback::_internal_devicestatejson() const {
  return _internal_has_devicestatejson()
      ? *FeedbackArgs_.devicestatejson_
      : reinterpret_cast< ::PXREAService::DeviceStateJson&>(::PXREAService::_DeviceStateJson_default_instance_);
}
inline const ::PXREAService::DeviceStateJson& ServerFeedback::devicestatejson() const {
  // @@protoc_insertion_point(field_get:PXREAService.ServerFeedback.devicestatejson)
  return _internal_devicestatejson();
}
inline ::PXREAService::DeviceStateJson* ServerFeedback::unsafe_arena_release_devicestatejson() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PXREAService.ServerFeedback.devicestatejson)
  if (_internal_has_devicestatejson()) {
    clear_has_FeedbackArgs();
    ::PXREAService::DeviceStateJson* temp = FeedbackArgs_.devicestatejson_;
    FeedbackArgs_.devicestatejson_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerFeedback::unsafe_arena_set_allocated_devicestatejson(::PXREAService::DeviceStateJson* devicestatejson) {
  clear_FeedbackArgs();
  if (devicestatejson) {
    set_has_devicestatejson();
    FeedbackArgs_.devicestatejson_ = devicestatejson;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PXREAService.ServerFeedback.devicestatejson)
}
inline ::PXREAService::DeviceStateJson* ServerFeedback::_internal_mutable_devicestatejson() {
  if (!_internal_has_devicestatejson()) {
    clear_FeedbackArgs();
    set_has_devicestatejson();
    FeedbackArgs_.devicestatejson_ = CreateMaybeMessage< ::PXREAService::DeviceStateJson >(GetArenaForAllocation());
  }
  return FeedbackArgs_.devicestatejson_;
}
inline ::PXREAService::DeviceStateJson* ServerFeedback::mutable_devicestatejson() {
  ::PXREAService::DeviceStateJson* _msg = _internal_mutable_devicestatejson();
  // @@protoc_insertion_point(field_mutable:PXREAService.ServerFeedback.devicestatejson)
  return _msg;
}

inline bool ServerFeedback::has_FeedbackArgs() const {
  return FeedbackArgs_case() != FEEDBACKARGS_NOT_SET;
}
inline void ServerFeedback::clear_has_FeedbackArgs() {
  _oneof_case_[0] = FEEDBACKARGS_NOT_SET;
}
inline ServerFeedback::FeedbackArgsCase ServerFeedback::FeedbackArgs_case() const {
  return ServerFeedback::FeedbackArgsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VrParam

// uint32 width = 1;
inline void VrParam::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VrParam::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VrParam::width() const {
  // @@protoc_insertion_point(field_get:PXREAService.VrParam.width)
  return _internal_width();
}
inline void VrParam::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void VrParam::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:PXREAService.VrParam.width)
}

// uint32 height = 2;
inline void VrParam::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VrParam::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VrParam::height() const {
  // @@protoc_insertion_point(field_get:PXREAService.VrParam.height)
  return _internal_height();
}
inline void VrParam::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void VrParam::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:PXREAService.VrParam.height)
}

// uint32 fps = 3;
inline void VrParam::clear_fps() {
  fps_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VrParam::_internal_fps() const {
  return fps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VrParam::fps() const {
  // @@protoc_insertion_point(field_get:PXREAService.VrParam.fps)
  return _internal_fps();
}
inline void VrParam::_internal_set_fps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  fps_ = value;
}
inline void VrParam::set_fps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:PXREAService.VrParam.fps)
}

// -------------------------------------------------------------------

// DeviceBattery

// string devid = 1;
inline void DeviceBattery::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceBattery::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceBattery.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceBattery::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceBattery.devid)
}
inline std::string* DeviceBattery::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceBattery.devid)
  return _s;
}
inline const std::string& DeviceBattery::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceBattery::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceBattery::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceBattery::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceBattery.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceBattery::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceBattery.devid)
}

// uint32 battery = 2;
inline void DeviceBattery::clear_battery() {
  battery_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceBattery::_internal_battery() const {
  return battery_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceBattery::battery() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceBattery.battery)
  return _internal_battery();
}
inline void DeviceBattery::_internal_set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  battery_ = value;
}
inline void DeviceBattery::set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:PXREAService.DeviceBattery.battery)
}

// -------------------------------------------------------------------

// DeviceStatus

// string devid = 1;
inline void DeviceStatus::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceStatus::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceStatus.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStatus::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceStatus.devid)
}
inline std::string* DeviceStatus::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceStatus.devid)
  return _s;
}
inline const std::string& DeviceStatus::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceStatus::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceStatus::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceStatus::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceStatus.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceStatus::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceStatus.devid)
}

// int32 status = 2;
inline void DeviceStatus::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceStatus::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceStatus::status() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceStatus.status)
  return _internal_status();
}
inline void DeviceStatus::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void DeviceStatus::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:PXREAService.DeviceStatus.status)
}

// -------------------------------------------------------------------

// DeviceModel

// string devid = 1;
inline void DeviceModel::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceModel::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceModel.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceModel::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceModel.devid)
}
inline std::string* DeviceModel::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceModel.devid)
  return _s;
}
inline const std::string& DeviceModel::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceModel::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceModel::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceModel::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceModel.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceModel::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceModel.devid)
}

// string model = 2;
inline void DeviceModel::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& DeviceModel::model() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceModel.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceModel::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceModel.model)
}
inline std::string* DeviceModel::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceModel.model)
  return _s;
}
inline const std::string& DeviceModel::_internal_model() const {
  return model_.Get();
}
inline void DeviceModel::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceModel::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceModel::release_model() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceModel.model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceModel::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceModel.model)
}

// -------------------------------------------------------------------

// CurrentApplication

// string devid = 1;
inline void CurrentApplication::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& CurrentApplication::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.CurrentApplication.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentApplication::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.CurrentApplication.devid)
}
inline std::string* CurrentApplication::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.CurrentApplication.devid)
  return _s;
}
inline const std::string& CurrentApplication::_internal_devid() const {
  return devid_.Get();
}
inline void CurrentApplication::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrentApplication::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrentApplication::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.CurrentApplication.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrentApplication::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.CurrentApplication.devid)
}

// string appname = 2;
inline void CurrentApplication::clear_appname() {
  appname_.ClearToEmpty();
}
inline const std::string& CurrentApplication::appname() const {
  // @@protoc_insertion_point(field_get:PXREAService.CurrentApplication.appname)
  return _internal_appname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentApplication::set_appname(ArgT0&& arg0, ArgT... args) {
 
 appname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.CurrentApplication.appname)
}
inline std::string* CurrentApplication::mutable_appname() {
  std::string* _s = _internal_mutable_appname();
  // @@protoc_insertion_point(field_mutable:PXREAService.CurrentApplication.appname)
  return _s;
}
inline const std::string& CurrentApplication::_internal_appname() const {
  return appname_.Get();
}
inline void CurrentApplication::_internal_set_appname(const std::string& value) {
  
  appname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrentApplication::_internal_mutable_appname() {
  
  return appname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrentApplication::release_appname() {
  // @@protoc_insertion_point(field_release:PXREAService.CurrentApplication.appname)
  return appname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrentApplication::set_allocated_appname(std::string* appname) {
  if (appname != nullptr) {
    
  } else {
    
  }
  appname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.CurrentApplication.appname)
}

// -------------------------------------------------------------------

// ControllerBattery

// string devid = 1;
inline void ControllerBattery::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& ControllerBattery::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerBattery.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControllerBattery::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ControllerBattery.devid)
}
inline std::string* ControllerBattery::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.ControllerBattery.devid)
  return _s;
}
inline const std::string& ControllerBattery::_internal_devid() const {
  return devid_.Get();
}
inline void ControllerBattery::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControllerBattery::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControllerBattery::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.ControllerBattery.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControllerBattery::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ControllerBattery.devid)
}

// int32 controllerid = 2;
inline void ControllerBattery::clear_controllerid() {
  controllerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ControllerBattery::_internal_controllerid() const {
  return controllerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ControllerBattery::controllerid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerBattery.controllerid)
  return _internal_controllerid();
}
inline void ControllerBattery::_internal_set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  controllerid_ = value;
}
inline void ControllerBattery::set_controllerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_controllerid(value);
  // @@protoc_insertion_point(field_set:PXREAService.ControllerBattery.controllerid)
}

// bool connected = 3;
inline void ControllerBattery::clear_connected() {
  connected_ = false;
}
inline bool ControllerBattery::_internal_connected() const {
  return connected_;
}
inline bool ControllerBattery::connected() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerBattery.connected)
  return _internal_connected();
}
inline void ControllerBattery::_internal_set_connected(bool value) {
  
  connected_ = value;
}
inline void ControllerBattery::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:PXREAService.ControllerBattery.connected)
}

// uint32 battery = 4;
inline void ControllerBattery::clear_battery() {
  battery_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ControllerBattery::_internal_battery() const {
  return battery_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ControllerBattery::battery() const {
  // @@protoc_insertion_point(field_get:PXREAService.ControllerBattery.battery)
  return _internal_battery();
}
inline void ControllerBattery::_internal_set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  battery_ = value;
}
inline void ControllerBattery::set_battery(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:PXREAService.ControllerBattery.battery)
}

// -------------------------------------------------------------------

// DeviceBlob

// string devid = 1;
inline void DeviceBlob::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceBlob::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceBlob.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceBlob::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceBlob.devid)
}
inline std::string* DeviceBlob::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceBlob.devid)
  return _s;
}
inline const std::string& DeviceBlob::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceBlob::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceBlob::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceBlob::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceBlob.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceBlob::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceBlob.devid)
}

// bytes content = 2;
inline void DeviceBlob::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& DeviceBlob::content() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceBlob.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceBlob::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceBlob.content)
}
inline std::string* DeviceBlob::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceBlob.content)
  return _s;
}
inline const std::string& DeviceBlob::_internal_content() const {
  return content_.Get();
}
inline void DeviceBlob::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceBlob::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceBlob::release_content() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceBlob.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceBlob::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceBlob.content)
}

// -------------------------------------------------------------------

// DeviceMonitorParameter

// string devid = 1;
inline void DeviceMonitorParameter::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceMonitorParameter::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceMonitorParameter.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMonitorParameter::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceMonitorParameter.devid)
}
inline std::string* DeviceMonitorParameter::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceMonitorParameter.devid)
  return _s;
}
inline const std::string& DeviceMonitorParameter::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceMonitorParameter::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceMonitorParameter::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceMonitorParameter::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceMonitorParameter.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceMonitorParameter::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceMonitorParameter.devid)
}

// uint32 width = 2;
inline void DeviceMonitorParameter::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceMonitorParameter::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceMonitorParameter::width() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceMonitorParameter.width)
  return _internal_width();
}
inline void DeviceMonitorParameter::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void DeviceMonitorParameter::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:PXREAService.DeviceMonitorParameter.width)
}

// uint32 height = 3;
inline void DeviceMonitorParameter::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceMonitorParameter::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceMonitorParameter::height() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceMonitorParameter.height)
  return _internal_height();
}
inline void DeviceMonitorParameter::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void DeviceMonitorParameter::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:PXREAService.DeviceMonitorParameter.height)
}

// -------------------------------------------------------------------

// VideoFrameInfo

// string devid = 1;
inline void VideoFrameInfo::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& VideoFrameInfo::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoFrameInfo.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoFrameInfo::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.VideoFrameInfo.devid)
}
inline std::string* VideoFrameInfo::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.VideoFrameInfo.devid)
  return _s;
}
inline const std::string& VideoFrameInfo::_internal_devid() const {
  return devid_.Get();
}
inline void VideoFrameInfo::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoFrameInfo::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoFrameInfo::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.VideoFrameInfo.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoFrameInfo::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.VideoFrameInfo.devid)
}

// uint32 frameSize = 2;
inline void VideoFrameInfo::clear_framesize() {
  framesize_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::_internal_framesize() const {
  return framesize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::framesize() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoFrameInfo.frameSize)
  return _internal_framesize();
}
inline void VideoFrameInfo::_internal_set_framesize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  framesize_ = value;
}
inline void VideoFrameInfo::set_framesize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_framesize(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoFrameInfo.frameSize)
}

// uint32 width = 3;
inline void VideoFrameInfo::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::width() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoFrameInfo.width)
  return _internal_width();
}
inline void VideoFrameInfo::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void VideoFrameInfo::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoFrameInfo.width)
}

// uint32 height = 4;
inline void VideoFrameInfo::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::height() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoFrameInfo.height)
  return _internal_height();
}
inline void VideoFrameInfo::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void VideoFrameInfo::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoFrameInfo.height)
}

// uint32 bytesPerLine = 5;
inline void VideoFrameInfo::clear_bytesperline() {
  bytesperline_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::_internal_bytesperline() const {
  return bytesperline_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameInfo::bytesperline() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoFrameInfo.bytesPerLine)
  return _internal_bytesperline();
}
inline void VideoFrameInfo::_internal_set_bytesperline(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  bytesperline_ = value;
}
inline void VideoFrameInfo::set_bytesperline(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bytesperline(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoFrameInfo.bytesPerLine)
}

// int32 pixFormat = 6;
inline void VideoFrameInfo::clear_pixformat() {
  pixformat_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoFrameInfo::_internal_pixformat() const {
  return pixformat_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoFrameInfo::pixformat() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoFrameInfo.pixFormat)
  return _internal_pixformat();
}
inline void VideoFrameInfo::_internal_set_pixformat(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pixformat_ = value;
}
inline void VideoFrameInfo::set_pixformat(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pixformat(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoFrameInfo.pixFormat)
}

// -------------------------------------------------------------------

// DeviceMonitorSharedMemoryKey

// string smkey = 1;
inline void DeviceMonitorSharedMemoryKey::clear_smkey() {
  smkey_.ClearToEmpty();
}
inline const std::string& DeviceMonitorSharedMemoryKey::smkey() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceMonitorSharedMemoryKey.smkey)
  return _internal_smkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMonitorSharedMemoryKey::set_smkey(ArgT0&& arg0, ArgT... args) {
 
 smkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceMonitorSharedMemoryKey.smkey)
}
inline std::string* DeviceMonitorSharedMemoryKey::mutable_smkey() {
  std::string* _s = _internal_mutable_smkey();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceMonitorSharedMemoryKey.smkey)
  return _s;
}
inline const std::string& DeviceMonitorSharedMemoryKey::_internal_smkey() const {
  return smkey_.Get();
}
inline void DeviceMonitorSharedMemoryKey::_internal_set_smkey(const std::string& value) {
  
  smkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceMonitorSharedMemoryKey::_internal_mutable_smkey() {
  
  return smkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceMonitorSharedMemoryKey::release_smkey() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceMonitorSharedMemoryKey.smkey)
  return smkey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceMonitorSharedMemoryKey::set_allocated_smkey(std::string* smkey) {
  if (smkey != nullptr) {
    
  } else {
    
  }
  smkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), smkey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceMonitorSharedMemoryKey.smkey)
}

// -------------------------------------------------------------------

// VideoControlResult

// string devid = 1;
inline void VideoControlResult::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& VideoControlResult::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoControlResult.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoControlResult::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.VideoControlResult.devid)
}
inline std::string* VideoControlResult::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.VideoControlResult.devid)
  return _s;
}
inline const std::string& VideoControlResult::_internal_devid() const {
  return devid_.Get();
}
inline void VideoControlResult::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoControlResult::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoControlResult::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.VideoControlResult.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoControlResult::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.VideoControlResult.devid)
}

// string action = 2;
inline void VideoControlResult::clear_action() {
  action_.ClearToEmpty();
}
inline const std::string& VideoControlResult::action() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoControlResult.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoControlResult::set_action(ArgT0&& arg0, ArgT... args) {
 
 action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.VideoControlResult.action)
}
inline std::string* VideoControlResult::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:PXREAService.VideoControlResult.action)
  return _s;
}
inline const std::string& VideoControlResult::_internal_action() const {
  return action_.Get();
}
inline void VideoControlResult::_internal_set_action(const std::string& value) {
  
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoControlResult::_internal_mutable_action() {
  
  return action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoControlResult::release_action() {
  // @@protoc_insertion_point(field_release:PXREAService.VideoControlResult.action)
  return action_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoControlResult::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.VideoControlResult.action)
}

// int32 result = 3;
inline void VideoControlResult::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoControlResult::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoControlResult::result() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoControlResult.result)
  return _internal_result();
}
inline void VideoControlResult::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void VideoControlResult::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoControlResult.result)
}

// int32 errorcode = 4;
inline void VideoControlResult::clear_errorcode() {
  errorcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoControlResult::_internal_errorcode() const {
  return errorcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoControlResult::errorcode() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoControlResult.errorcode)
  return _internal_errorcode();
}
inline void VideoControlResult::_internal_set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  errorcode_ = value;
}
inline void VideoControlResult::set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:PXREAService.VideoControlResult.errorcode)
}

// string detail = 5;
inline void VideoControlResult::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& VideoControlResult::detail() const {
  // @@protoc_insertion_point(field_get:PXREAService.VideoControlResult.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoControlResult::set_detail(ArgT0&& arg0, ArgT... args) {
 
 detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.VideoControlResult.detail)
}
inline std::string* VideoControlResult::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:PXREAService.VideoControlResult.detail)
  return _s;
}
inline const std::string& VideoControlResult::_internal_detail() const {
  return detail_.Get();
}
inline void VideoControlResult::_internal_set_detail(const std::string& value) {
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoControlResult::_internal_mutable_detail() {
  
  return detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoControlResult::release_detail() {
  // @@protoc_insertion_point(field_release:PXREAService.VideoControlResult.detail)
  return detail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoControlResult::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detail,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.VideoControlResult.detail)
}

// -------------------------------------------------------------------

// DeviceControlParameterJson

// string devid = 1;
inline void DeviceControlParameterJson::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceControlParameterJson::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceControlParameterJson.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceControlParameterJson::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceControlParameterJson.devid)
}
inline std::string* DeviceControlParameterJson::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceControlParameterJson.devid)
  return _s;
}
inline const std::string& DeviceControlParameterJson::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceControlParameterJson::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceControlParameterJson::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceControlParameterJson::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceControlParameterJson.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceControlParameterJson::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceControlParameterJson.devid)
}

// string parameter = 2;
inline void DeviceControlParameterJson::clear_parameter() {
  parameter_.ClearToEmpty();
}
inline const std::string& DeviceControlParameterJson::parameter() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceControlParameterJson.parameter)
  return _internal_parameter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceControlParameterJson::set_parameter(ArgT0&& arg0, ArgT... args) {
 
 parameter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceControlParameterJson.parameter)
}
inline std::string* DeviceControlParameterJson::mutable_parameter() {
  std::string* _s = _internal_mutable_parameter();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceControlParameterJson.parameter)
  return _s;
}
inline const std::string& DeviceControlParameterJson::_internal_parameter() const {
  return parameter_.Get();
}
inline void DeviceControlParameterJson::_internal_set_parameter(const std::string& value) {
  
  parameter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceControlParameterJson::_internal_mutable_parameter() {
  
  return parameter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceControlParameterJson::release_parameter() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceControlParameterJson.parameter)
  return parameter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceControlParameterJson::set_allocated_parameter(std::string* parameter) {
  if (parameter != nullptr) {
    
  } else {
    
  }
  parameter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parameter,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceControlParameterJson.parameter)
}

// -------------------------------------------------------------------

// DeviceStateJson

// string devid = 1;
inline void DeviceStateJson::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& DeviceStateJson::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceStateJson.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStateJson::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceStateJson.devid)
}
inline std::string* DeviceStateJson::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceStateJson.devid)
  return _s;
}
inline const std::string& DeviceStateJson::_internal_devid() const {
  return devid_.Get();
}
inline void DeviceStateJson::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceStateJson::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceStateJson::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceStateJson.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceStateJson::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceStateJson.devid)
}

// string statejson = 2;
inline void DeviceStateJson::clear_statejson() {
  statejson_.ClearToEmpty();
}
inline const std::string& DeviceStateJson::statejson() const {
  // @@protoc_insertion_point(field_get:PXREAService.DeviceStateJson.statejson)
  return _internal_statejson();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStateJson::set_statejson(ArgT0&& arg0, ArgT... args) {
 
 statejson_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.DeviceStateJson.statejson)
}
inline std::string* DeviceStateJson::mutable_statejson() {
  std::string* _s = _internal_mutable_statejson();
  // @@protoc_insertion_point(field_mutable:PXREAService.DeviceStateJson.statejson)
  return _s;
}
inline const std::string& DeviceStateJson::_internal_statejson() const {
  return statejson_.Get();
}
inline void DeviceStateJson::_internal_set_statejson(const std::string& value) {
  
  statejson_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceStateJson::_internal_mutable_statejson() {
  
  return statejson_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceStateJson::release_statejson() {
  // @@protoc_insertion_point(field_release:PXREAService.DeviceStateJson.statejson)
  return statejson_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceStateJson::set_allocated_statejson(std::string* statejson) {
  if (statejson != nullptr) {
    
  } else {
    
  }
  statejson_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), statejson,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.DeviceStateJson.statejson)
}

// -------------------------------------------------------------------

// ScreenMonitorParameter

// string devid = 1;
inline void ScreenMonitorParameter::clear_devid() {
  devid_.ClearToEmpty();
}
inline const std::string& ScreenMonitorParameter::devid() const {
  // @@protoc_insertion_point(field_get:PXREAService.ScreenMonitorParameter.devid)
  return _internal_devid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScreenMonitorParameter::set_devid(ArgT0&& arg0, ArgT... args) {
 
 devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PXREAService.ScreenMonitorParameter.devid)
}
inline std::string* ScreenMonitorParameter::mutable_devid() {
  std::string* _s = _internal_mutable_devid();
  // @@protoc_insertion_point(field_mutable:PXREAService.ScreenMonitorParameter.devid)
  return _s;
}
inline const std::string& ScreenMonitorParameter::_internal_devid() const {
  return devid_.Get();
}
inline void ScreenMonitorParameter::_internal_set_devid(const std::string& value) {
  
  devid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ScreenMonitorParameter::_internal_mutable_devid() {
  
  return devid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ScreenMonitorParameter::release_devid() {
  // @@protoc_insertion_point(field_release:PXREAService.ScreenMonitorParameter.devid)
  return devid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ScreenMonitorParameter::set_allocated_devid(std::string* devid) {
  if (devid != nullptr) {
    
  } else {
    
  }
  devid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PXREAService.ScreenMonitorParameter.devid)
}

// int32 quality = 2;
inline void ScreenMonitorParameter::clear_quality() {
  quality_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScreenMonitorParameter::_internal_quality() const {
  return quality_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScreenMonitorParameter::quality() const {
  // @@protoc_insertion_point(field_get:PXREAService.ScreenMonitorParameter.quality)
  return _internal_quality();
}
inline void ScreenMonitorParameter::_internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  quality_ = value;
}
inline void ScreenMonitorParameter::set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:PXREAService.ScreenMonitorParameter.quality)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PXREAService

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_PXREAService_2eproto
